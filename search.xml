<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何使用 Electron 和 React 构建一个 APP</title>
    <url>/build-a-app-width-electron-and-react/</url>
    <content><![CDATA[<p>这篇文章主要记录了，使用 Electron 构建的一个 APP 过程的关键步骤和遇到的问题及解决方法。</p>
<h1 id="最终成品效果图"><a href="#最终成品效果图" class="headerlink" title="最终成品效果图"></a>最终成品效果图</h1><p><img src="/uploads/build-a-app-width-electron-and-react/electron-preview.gif" alt="最终效果图"><br><a href="https://github.com/hiyangguo/bt-radish-app">查看源码</a></p>
<span id="more"></span>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>首先使用 <code>create-react-app</code> 新建一个 react app。因为这玩意儿新建的时候会帮你初始化<code>npm</code>，相当刺激。<br>其实主要是使用<code>create-react-app</code>的时候必须要指定一个名字。<br>然后他就在当前目录下创建了一个同名的文件夹，所有东西都放在这个文件夹下面了。（可能我没找到如何在当前目录创建的方法，欢迎指正）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app test-app</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/27840803">npx 是什么</a></p>
</blockquote>
<p>安装好以后，我们再按照 Electron 官方示例继续。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev electron</span><br></pre></td></tr></table></figure><br>然后。。。就卡住了，卡住了有木有？！是我们姿势不对么？这里什么也没写啊。什么鬼？<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; electron@1.8.4 postinstall /Users/godfery/GitRepo/hiyangguo.github.io/node_modules/electron</span><br><span class="line">&gt; node install.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">... and 1 more</span><br></pre></td></tr></table></figure><br>那我们加个参数，看看到底是什么情况<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install  --save-dev electron --verbose </span><br></pre></td></tr></table></figure><br>之后我们就能看到了，是在下载 electron 的地方，下载不下来，龟速，所以我们需要就<a href="https://electronjs.org/docs/tutorial/installation#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F%E5%92%8C%E7%BC%93%E5%AD%98">使用国内的镜像</a>。<br>在根目录新建一个 <code>.npmrc</code> 文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 这里推荐使用淘宝镜像，当然也可以使用其他镜像</span><br><span class="line">electron_mirror&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;</span><br></pre></td></tr></table></figure><br>也可以使用声明临时变量的方式<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> electron_mirror=<span class="string">&quot;https://npm.taobao.org/mirrors/electron/&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>之后再执行<code>npm install  --save-dev electron</code> 就可以顺利的安装了。<br>然后修改<code>package.json</code><br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line"><span class="addition">+ &quot;main&quot;: &quot;main.js&quot;,</span></span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-scripts&quot;: &quot;1.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;start-electron&quot;: &quot;electron .&quot;,</span></span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,</span><br><span class="line">    &quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;electron&quot;: &quot;^1.8.4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>之后在根目录新建一个<code>main.js</code>文件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保持一个对于 window 对象的全局引用，如果你不这样做，</span></span><br><span class="line"><span class="comment">// 当 JavaScript 对象被垃圾回收， window 会被自动地关闭</span></span><br><span class="line"><span class="keyword">let</span> win</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建浏览器窗口。</span></span><br><span class="line">  win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后加载应用的 index.html。</span></span><br><span class="line">  win.loadURL(<span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开开发者工具。</span></span><br><span class="line">  win.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 window 被关闭，这个事件会被触发。</span></span><br><span class="line">  win.on(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消引用 window 对象，如果你的应用支持多窗口的话，</span></span><br><span class="line">    <span class="comment">// 通常会把多个 window 对象存放在一个数组里面，</span></span><br><span class="line">    <span class="comment">// 与此同时，你应该删除相应的元素。</span></span><br><span class="line">    win = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Electron 会在初始化后并准备</span></span><br><span class="line"><span class="comment">// 创建浏览器窗口时，调用这个函数。</span></span><br><span class="line"><span class="comment">// 部分 API 在 ready 事件触发后才能使用。</span></span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当全部窗口关闭时退出。</span></span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span></span><br><span class="line">  <span class="comment">// 否则绝大部分应用及其菜单栏会保持激活。</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">&#x27;darwin&#x27;</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在macOS上，当单击dock图标并且没有其他窗口打开时，</span></span><br><span class="line">  <span class="comment">// 通常在应用程序中重新创建一个窗口。</span></span><br><span class="line">  <span class="keyword">if</span> (win === <span class="literal">null</span>) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>最后运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br><span class="line">npm run start-electron</span><br></pre></td></tr></table></figure></p>
<p>当当当当！<br><img src="/uploads/build-a-app-width-electron-and-react/electron-with-react-preview.png" alt="electron-with-react-preview"></p>
<h1 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h1><p>既然是用<code>react</code>开发，肯定是要用<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN">React Developer Tools</a>的，这里就来说一下，如何在<code>electron</code>中使用拓展。(以 mac 为例)</p>
<ol>
<li>打开 Chrome 浏览器，导航到 <code>chrome://extensions</code>，找到 React Developer Tools 插件的 ID：<strong>fmkadmapgofadopljbjfkapdkoienihi</strong></li>
<li>进入 <code>~/Library/Application Support/Google/Chrome/Default/Extensions</code> 目录。在 Finder 中，点击 前往 &gt; 前往文件夹。（或使用快捷键 <code>shift + command + G</code>）。粘贴即可。</li>
<li>进入 <code>fmkadmapgofadopljbjfkapdkoienihi</code> 文件夹，子目录<code>3.2.1_0</code>（也可能是其他的，反正是个版本号）中的的文件拷贝项目根目录下<code>chrome-extensions</code>目录中，并重命名为<code>react-dev-tools</code>。</li>
<li>修改代码<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)</span><br><span class="line"><span class="addition">+ const path = require(&#x27;path&#x27;)</span></span><br><span class="line"></span><br><span class="line">// 保持一个对于 window 对象的全局引用，如果你不这样做，</span><br><span class="line">// 当 JavaScript 对象被垃圾回收， window 会被自动地关闭</span><br><span class="line">let win</span><br><span class="line"></span><br><span class="line">function createWindow() &#123;</span><br><span class="line"><span class="addition">+ installExtensions()</span></span><br><span class="line"></span><br><span class="line">  // 创建浏览器窗口。</span><br><span class="line">  win = new BrowserWindow(&#123; width: 800, height: 600 &#125;)</span><br><span class="line"></span><br><span class="line">  // 然后加载应用的 index.html。</span><br><span class="line">  win.loadURL(&#x27;http://localhost:3000&#x27;)</span><br><span class="line"></span><br><span class="line">  // 打开开发者工具。</span><br><span class="line">  win.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  // 当 window 被关闭，这个事件会被触发。</span><br><span class="line">  win.on(&#x27;closed&#x27;, () =&gt; &#123;</span><br><span class="line">    // 取消引用 window 对象，如果你的应用支持多窗口的话，</span><br><span class="line">    // 通常会把多个 window 对象存放在一个数组里面，</span><br><span class="line">    // 与此同时，你应该删除相应的元素。</span><br><span class="line">    win = null</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Electron 会在初始化后并准备</span><br><span class="line">// 创建浏览器窗口时，调用这个函数。</span><br><span class="line">// 部分 API 在 ready 事件触发后才能使用。</span><br><span class="line">app.on(&#x27;ready&#x27;, createWindow)</span><br><span class="line"></span><br><span class="line">// 当全部窗口关闭时退出。</span><br><span class="line">app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123;</span><br><span class="line">  // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span><br><span class="line">  // 否则绝大部分应用及其菜单栏会保持激活。</span><br><span class="line">  if (process.platform !== &#x27;darwin&#x27;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(&#x27;activate&#x27;, () =&gt; &#123;</span><br><span class="line">  // 在macOS上，当单击dock图标并且没有其他窗口打开时，</span><br><span class="line">  // 通常在应用程序中重新创建一个窗口。</span><br><span class="line">  if (win <span class="comment">=== null) &#123;</span></span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="addition">+ function installExtensions() &#123;</span></span><br><span class="line"><span class="addition">+   BrowserWindow.addDevToolsExtension(path.join(__dirname, &#x27;chrome-extensions&#x27;, &#x27;react-dev-tools&#x27;));</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>之后重启 electron<br><img src="/uploads/build-a-app-width-electron-and-react/electron-with-react-dev-tools-preview.png" alt="安装好 react-developer-tools的 截图"></p>
<h1 id="create-react-app-使用-less"><a href="#create-react-app-使用-less" class="headerlink" title="create-react-app  使用 less"></a>create-react-app  使用 less</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-css-preprocessor-sass-less-etc">官方推荐的方式</a>。</p>
<p>大致是说：</p>
<ul>
<li>安装 less </li>
<li>使用 less 编译</li>
<li>添加 watch 监控文件变更实时编译</li>
<li>引入最终编译的 css 文件</li>
</ul>
<p>妈耶，简直 low 到爆啊。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>运行 <code>npm run eject</code> ，然后改 webpack 的 config 。这方法破坏了整个项目，简直了。也不推荐。</p>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>那就没有什么既不破坏项目，又可以方便的使用 less 的方法呢？当然有<br>使用 <strong><a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a></strong> 即可，方便简单的扩展 create-react-app</p>
<ol>
<li>安装 <strong>react-app-rewired</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react-app-rewired react-app-rewire-less --save-dev</span><br></pre></td></tr></table></figure></li>
<li>在根目录创建<code>config-overrides.js</code> 文件。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rewireLess = <span class="built_in">require</span>(<span class="string">&#x27;react-app-rewire-less&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">  config = rewireLess(config, env);</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>将 <code>packge.json</code> 中所有的 <code>react-scripts</code> 换成 <code>react-app-rewired</code><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-scripts&quot;: &quot;1.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-electron&quot;: &quot;electron .&quot;,</span><br><span class="line"><span class="deletion">-   &quot;start&quot;: &quot;react-scripts start&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;start&quot;: &quot;react-app-rewired start&quot;,</span></span><br><span class="line"><span class="deletion">-   &quot;build&quot;: &quot;react-scripts build&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;build&quot;: &quot;react-app-rewired build&quot;,</span></span><br><span class="line"><span class="deletion">-   &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;,</span></span><br><span class="line"><span class="deletion">-   &quot;eject&quot;: &quot;react-scripts eject&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;electron&quot;: &quot;^1.8.4&quot;,</span><br><span class="line">    &quot;react-app-rewire-less&quot;: &quot;^2.1.1&quot;,</span><br><span class="line">    &quot;react-app-rewired&quot;: &quot;^1.5.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行  <code>npm run start</code></li>
</ol>
<h1 id="electron-跨域"><a href="#electron-跨域" class="headerlink" title="electron 跨域"></a>electron 跨域</h1><p>electron 可以禁用跨域检查<br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">win = new BrowserWindow(&#123;</span><br><span class="line">    width: 800,</span><br><span class="line">    height: 600,</span><br><span class="line"><span class="addition">+   //禁用跨域检查</span></span><br><span class="line"><span class="addition">+   webPreferences: &#123;</span></span><br><span class="line"><span class="addition">+     webSecurity: false</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>开发过程不再赘述，有兴趣可以直接<a href="https://github.com/hiyangguo/bt-radish-app">查看源码</a>。后续会单开一篇文章详细讲解开发过程以及如何更好的发挥 electron 的优势。</p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="修改-electron-代码"><a href="#修改-electron-代码" class="headerlink" title="修改 electron 代码"></a>修改 electron 代码</h2><p>修改<code>package.json</code>中的 <code>script</code>， 添加<code>NODE_ENV</code> 环境变量用于区分环境<br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &quot;start-electron&quot;: &quot;electron .&quot;,</span></span><br><span class="line"><span class="addition">+ &quot;start-electron&quot;: &quot;NODE_ENV=development electron .&quot;,</span></span><br></pre></td></tr></table></figure><br>然后修改 <code>main.js</code><br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"><span class="addition">+ const url = require(&#x27;url&#x27;)</span></span><br><span class="line"><span class="addition">+ const IS_DEV = process.env.NODE_ENV === &#x27;development&#x27;</span></span><br><span class="line"></span><br><span class="line">// 保持一个对于 window 对象的全局引用，如果你不这样做，</span><br><span class="line">// 当 JavaScript 对象被垃圾回收， window 会被自动地关闭</span><br><span class="line">let win</span><br><span class="line"></span><br><span class="line">function createWindow() &#123;</span><br><span class="line">  installExtensions()</span><br><span class="line"></span><br><span class="line">  // 创建浏览器窗口。</span><br><span class="line">  win = new BrowserWindow(&#123;</span><br><span class="line">    width: 800,</span><br><span class="line">    height: 600,</span><br><span class="line">    //禁用跨域检查</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      webSecurity: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  // 然后加载应用的 index.html。</span></span><br><span class="line"><span class="deletion">-  win.loadURL(&#x27;http://localhost:3000&#x27;)</span></span><br><span class="line"><span class="addition">+  // 加载应用</span></span><br><span class="line"><span class="addition">+  const staticIndexPath = path.join(__dirname, &#x27;./index.html&#x27;);</span></span><br><span class="line"><span class="addition">+  const main = IS_DEV ? `http://localhost:3000` : url.format(&#123;</span></span><br><span class="line"><span class="addition">+    pathname: staticIndexPath,</span></span><br><span class="line"><span class="addition">+    protocol: &#x27;file:&#x27;,</span></span><br><span class="line"><span class="addition">+    slashes: true</span></span><br><span class="line"><span class="addition">+  &#125;);</span></span><br><span class="line"><span class="addition">+  win.loadURL(main)</span></span><br><span class="line"></span><br><span class="line">  // 打开开发者工具。</span><br><span class="line"><span class="deletion">-  win.webContents.openDevTools()</span></span><br><span class="line"><span class="addition">+  IS_DEV &amp;&amp;win.webContents.openDevTools()</span></span><br><span class="line"></span><br><span class="line">  // 当 window 被关闭，这个事件会被触发。</span><br><span class="line">  win.on(&#x27;closed&#x27;, () =&gt; &#123;</span><br><span class="line">    // 取消引用 window 对象，如果你的应用支持多窗口的话，</span><br><span class="line">    // 通常会把多个 window 对象存放在一个数组里面，</span><br><span class="line">    // 与此同时，你应该删除相应的元素。</span><br><span class="line">    win = null</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Electron 会在初始化后并准备</span><br><span class="line">// 创建浏览器窗口时，调用这个函数。</span><br><span class="line">// 部分 API 在 ready 事件触发后才能使用。</span><br><span class="line">app.on(&#x27;ready&#x27;, createWindow)</span><br><span class="line"></span><br><span class="line">// 当全部窗口关闭时退出。</span><br><span class="line">app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123;</span><br><span class="line">  // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span><br><span class="line">  // 否则绝大部分应用及其菜单栏会保持激活。</span><br><span class="line">  if (process.platform !== &#x27;darwin&#x27;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(&#x27;activate&#x27;, () =&gt; &#123;</span><br><span class="line">  // 在macOS上，当单击dock图标并且没有其他窗口打开时，</span><br><span class="line">  // 通常在应用程序中重新创建一个窗口。</span><br><span class="line">  if (win <span class="comment">=== null) &#123;</span></span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function installExtensions() &#123;</span><br><span class="line">  BrowserWindow.addDevToolsExtension(path.join(__dirname, &#x27;chrome-extensions&#x27;, &#x27;react-dev-tools&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="打包-1"><a href="#打包-1" class="headerlink" title="打包"></a>打包</h2><p>由于 <code>create-react-app</code> 默认打包的路径为 <code>/</code> 根目录，而在 electron 中，需要使用相对路径所以需要再次次改<code>package.json</code><br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line"><span class="addition">+ &quot;homepage&quot;: &quot;./&quot;,</span></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.2.0&quot;,</span><br><span class="line">    &quot;react-scripts&quot;: &quot;1.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-electron&quot;: &quot;NODE_ENV=development electron .&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;react-app-rewired start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-app-rewired build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;electron&quot;: &quot;^1.8.4&quot;,</span><br><span class="line">    &quot;react-app-rewire-less&quot;: &quot;^2.1.1&quot;,</span><br><span class="line">    &quot;react-app-rewired&quot;: &quot;^1.5.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>打包工具这里使用的是<a href="https://electron.build/">electron-builder</a>。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>安装 <code>electron-builder</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron-builder --save-dev</span><br></pre></td></tr></table></figure></li>
<li>修改配置，添加必要的文件。<ul>
<li>修改 <code>name</code>，<code>verison</code>，<code>description</code>，<code>author</code>字段</li>
<li>在 <code>./public</code>文件夹中放入 <code>icon.png</code> 文件</li>
<li>将 <code>main.js</code> 重命名为 <code>electron.js</code>，让如根目录<code>./public</code> 目录下。同时修改 <code>package.json</code></li>
<li>由于<code>electron-builder</code>中不能使用<code>dependencies</code>，所以<strong>务必将所有的<code>dependencies</code>加入<code>devDependencies</code></strong>。<br>最终的 <code>package.json</code>文件：</li>
</ul>
</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A Eleactron app with react.&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;Godfery.Yang&lt;hiyangguo@qq.com&gt;&quot;,</span><br><span class="line"><span class="deletion">- &quot;main&quot;: &quot;main.js&quot;,</span></span><br><span class="line"><span class="addition">+ &quot;main&quot;: &quot;./public/electron.js&quot;,</span></span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;homepage&quot;: &quot;./&quot;,</span><br><span class="line"><span class="deletion">-  &quot;dependencies&quot;: &#123;</span></span><br><span class="line"><span class="deletion">-    &quot;react&quot;: &quot;^16.2.0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;react-dom&quot;: &quot;^16.2.0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;react-scripts&quot;: &quot;1.1.1&quot;</span></span><br><span class="line"><span class="deletion">-  &#125;,</span></span><br><span class="line"><span class="addition">+  &quot;build&quot;: &#123;</span></span><br><span class="line"><span class="addition">+    &quot;mac&quot;: &#123;</span></span><br><span class="line"><span class="addition">+      &quot;category&quot;: &quot;demo&quot;</span></span><br><span class="line"><span class="addition">+    &#125;,</span></span><br><span class="line"><span class="addition">+    &quot;files&quot;: [</span></span><br><span class="line"><span class="addition">+      &#123;</span></span><br><span class="line"><span class="addition">+        &quot;from&quot;: &quot;./&quot;,</span></span><br><span class="line"><span class="addition">+        &quot;to&quot;: &quot;./&quot;,</span></span><br><span class="line"><span class="addition">+        &quot;filter&quot;: [</span></span><br><span class="line"><span class="addition">+          &quot;**/*&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;!node_modules&quot;</span></span><br><span class="line"><span class="addition">+        ]</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    ],</span></span><br><span class="line"><span class="addition">+    &quot;directories&quot;: &#123;</span></span><br><span class="line"><span class="addition">+      &quot;buildResources&quot;: &quot;public&quot;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-electron&quot;: &quot;NODE_ENV=development electron .&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;react-app-rewired start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-app-rewired build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;,</span><br><span class="line"><span class="addition">+   &quot;packager&quot;: &quot;npm run build &amp;&amp; rm -rf dist &amp;&amp; electron-builder&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;electron&quot;: &quot;^1.8.4&quot;,</span><br><span class="line">    &quot;electron-builder&quot;: &quot;^20.8.1&quot;,</span><br><span class="line"><span class="addition">+   &quot;react&quot;: &quot;^16.2.0&quot;,</span></span><br><span class="line">    &quot;react-app-rewire-less&quot;: &quot;^2.1.1&quot;,</span><br><span class="line">    &quot;react-app-rewired&quot;: &quot;^1.5.0&quot;,</span><br><span class="line"><span class="addition">+   &quot;react-dom&quot;: &quot;^16.2.0&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;react-scripts&quot;: &quot;1.1.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后运行<code>npm run packager</code> 即可得到 <code>dmg</code> 安装文件。</p>
<p><a href="https://github.com/hiyangguo/electron-with-react">起步demo 源代码</a></p>
<blockquote>
<p>参考文章<br><a href="https://medium.com/@kitze/%EF%B8%8F-from-react-to-an-electron-app-ready-for-production-a0468ecb1da3">From React to an Electron app ready for production</a><br><a href="https://electronjs.org/docs/tutorial/devtools-extension#%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E6%89%A9%E5%B1%95">如何加载一个开发者工具扩展</a><br><a href="https://electronjs.org/docs">Electron 官放文档</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>electron</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>跨页面(tab/window)通信的几种方法</title>
    <url>/cross-tab-communication/</url>
    <content><![CDATA[<p>今天开发一个功能遇到一个需求，在页面 A 点击查看详情后在页面 B 进行审核，审核后页面 B 关闭，然后刷新页面 A 的数据。思路大概就是：</p>
<h1 id="使用-webSocket-进行通讯"><a href="#使用-webSocket-进行通讯" class="headerlink" title="使用 webSocket 进行通讯"></a>使用 <code>webSocket</code> 进行通讯</h1><p>但是这样，工作量是巨大的，而且还需要后端支持。太麻烦了，对于我这种懒人来说，直接就放弃了。</p>
<h1 id="写个定时器，不断检查-Cookies-的变化"><a href="#写个定时器，不断检查-Cookies-的变化" class="headerlink" title="写个定时器，不断检查 Cookies 的变化"></a>写个定时器，不断检查 <code>Cookies</code> 的变化</h1><p>然后在<a href="http://stackoverflow.com/">stackoverflow</a>看到一个<a href="http://stackoverflow.com/questions/4079280/javascript-communication-between-browser-tabs-windows/4079423#4079423">方案</a>,大致思路是:</p>
<ol>
<li>在页面A设置一个使用 <code>setInterval</code> 定时器不断刷新，检查 <code>Cookies</code> 的值是否发生变化，如果变化就进行刷新的操作。</li>
<li><p>由于 <code>Cookies</code> 是在同域可读的，所以在页面 B 审核的时候改变 <code>Cookies</code> 的值，页面 A 自然是可以拿到的。<br>这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优(zhāng)雅（bī）。</p>
<span id="more"></span>
</li>
</ol>
<h1 id="localStorage的事件"><a href="#localStorage的事件" class="headerlink" title="localStorage的事件"></a><code>localStorage</code>的事件</h1><p>后来发现 <code>window</code> 有一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent">StorageEvent</a> ，每当 <code>localStorage</code> 改变的时候可以触发这个事件。（这个原理就像你给一个<code>DOM</code> 绑定了 <code>click</code> 事件，当你点击它的时候，就会自动触发。）也就是说，我给 <code>window</code> 绑定这个事件后，每当我改变 <code>localStorage</code> 的时候，他都会触发这个事件。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这个回调中的<code>event</code>与普通的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event#Properties">EVNET</a>,基本差不多，但是它比其他的<code>event</code>多了如下几个属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>受影响的 <code>localStorage</code> 的 <code>key</code></td>
</tr>
<tr>
<td>newValue</td>
<td>新的值</td>
</tr>
<tr>
<td>oldValue</td>
<td>旧的值</td>
</tr>
<tr>
<td>url</td>
<td>触发此事件的url</td>
</tr>
</tbody>
</table>
<p>每当一个页面改变了 <code>localStorage</code> 的值，都会触发这个事件。也就是说可以很容易的通过改变 <code>localStorage</code> 的值，来实现浏览器中跨页面( tab / window )之间的通讯。记住这个事件只有在 <code>localStorage</code> 发生<strong>改变</strong>的时候才会被触发，如果没改变则<strong>不会触发</strong>此事件。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;update&#x27;</span>,<span class="number">1</span>); <span class="comment">//触发</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;update&#x27;</span>,<span class="number">1</span>); <span class="comment">//不触发</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;update&#x27;</span>,<span class="number">2</span>); <span class="comment">//触发</span></span><br></pre></td></tr></table></figure><br>在使用的时候务必注意这一点。<br>最终实现代码:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面 A</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.key === <span class="string">&#x27;update_verify_list&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//页面更新操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面 B</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  获取一个随机id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>- 返回一个5位的随机字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Math</span>.random() * <span class="number">1E18</span>).toString(<span class="number">36</span>).slice(<span class="number">0</span>, <span class="number">5</span>).toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每当需要页面A更新时 执行此方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">localStorage</span>) &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;update_verify_list&#x27;</span>, randomId());<span class="comment">//为保证每次页面A都执行，此处我设置里一个随机字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参考：<a href="https://ponyfoo.com/articles/cross-tab-communication">https://ponyfoo.com/articles/cross-tab-communication</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>页面通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker 快速部署 shadowsocks</title>
    <url>/docker-deploy-shadowsocks/</url>
    <content><![CDATA[<h2 id="使用-docker-快速部署-shadowsocks"><a href="#使用-docker-快速部署-shadowsocks" class="headerlink" title="使用 docker 快速部署 shadowsocks"></a>使用 docker 快速部署 shadowsocks</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>安装 docker，如果是的环境是 centos，可以参考<a href="/install-docker-on-centos/">这篇文章</a>进行安装。本文以 <a href="https://github.com/shadowsocks/shadowsocks-libev">shadowsocks-libev</a> 为例。</p>
<span id="more"></span>
<h3 id="拉取-shadowsocks-libev"><a href="#拉取-shadowsocks-libev" class="headerlink" title="拉取 shadowsocks-libev"></a>拉取 shadowsocks-libev</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull appso/shadowsocks-libev</span><br></pre></td></tr></table></figure>
<h3 id="创建-shadowssocks-配置文件"><a href="#创建-shadowssocks-配置文件" class="headerlink" title="创建 shadowssocks 配置文件"></a>创建 shadowssocks 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;shadowsocks-libev&#x2F;</span><br><span class="line">vi &#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json</span><br></pre></td></tr></table></figure>
<p>将下面的内容修改后，粘贴进去。其中 <code>server_port</code> 就是可以随便改，<code>你的密码</code> 换成你需要的密码即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;server_port&quot;</span>: <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;你的密码&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-gcm&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;tcp_and_udp&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>vi</code> 中，按 <kbd>I</kbd> 键进入插入模式。粘贴完成后，按<kbd>Esc</kbd> 退出。再依次按<kbd>:</kbd><kbd>W</kbd> <kbd>Q</kbd><kbd>!</kbd><kbd>Enter</kbd>进行保存。</p>
<p>保存成功后，验证一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>
<p>输出的内容和上面你编辑的一样就是成功了。</p>
<p>###启动 docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1234:1234 -p 1234:1234/udp \</span><br><span class="line">       --name ss-libev \</span><br><span class="line">       -v /etc/shadowsocks-libev:/etc/shadowsocks-libev \</span><br><span class="line">       appso/shadowsocks-libev</span><br></pre></td></tr></table></figure>
<p>查看容器启动状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -as</span><br><span class="line"></span><br><span class="line">CONTAINER ID   IMAGE                     COMMAND                  CREATED              STATUS              PORTS                                                                                  NAMES      SIZE</span><br><span class="line">7da207676c01   appso/shadowsocks-libev   <span class="string">&quot;ss-server -c /etc/s…&quot;</span>   About a minute ago   Up About a minute   0.0.0.0:1234-&gt;1234/tcp, 0.0.0.0:1234-&gt;1234/udp, :::1234-&gt;1234/tcp, :::1234-&gt;1234/udp   ss-libev   0B (virtual 120MB)</span><br></pre></td></tr></table></figure>
<p>查看端口监听状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 1234</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqtvg7nyyij312u052q42.jpg" alt="执行结果"></p>
<p>这样就是 OK 了</p>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>和创建一样，先编辑配置文件，再重启 docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks-libev/config.json</span><br><span class="line">docker restart ss-libev</span><br></pre></td></tr></table></figure>
<h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>修改端口后需要先删除再重新启一个新的容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除旧的容器</span></span><br><span class="line">docker rm -f ss-libev</span><br><span class="line"><span class="comment"># 端口号换成你自己的</span></span><br><span class="line">docker run -d -p 1333:1333 -p 1333:1333/udp \</span><br><span class="line">       --name ss-libev \</span><br><span class="line">       -v /etc/shadowsocks-libev:/etc/shadowsocks-libev \</span><br><span class="line">       appso/shadowsocks-libev</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><blockquote>
<p><a href="https://haoyunlaile.github.io/2020/docker/docker-install-shadowsocks-libev/">https://haoyunlaile.github.io/2020/docker/docker-install-shadowsocks-libev/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>git永久删除文件</title>
    <url>/git-perpetual-remove-file/</url>
    <content><![CDATA[<h1 id="git删除文件后恢复和永久删除文件"><a href="#git删除文件后恢复和永久删除文件" class="headerlink" title="git删除文件后恢复和永久删除文件"></a>git删除文件后恢复和永久删除文件</h1><p>Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>当我们在日常使用中删除了文件，如果这个文件提交过就可以进行恢复。这篇文建，将告诉你如何对删除的文件进行恢复，以及如何彻底的删除某个文件。</p>
<span id="more"></span>
<p>假设我们新建了一个文件<code>test.txt</code>,并录入任意内容。然后进行提交。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新建一个 文件 并追加内容</span></span><br><span class="line">touch test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test&#x27;</span> &gt; test.txt </span><br><span class="line"><span class="comment"># 将此文件的更改添加到缓存区</span></span><br><span class="line">git add test.txt</span><br><span class="line"><span class="comment"># 提交缓存区中的内容</span></span><br><span class="line">git commit -m <span class="string">&quot;update:添加了一个测试文件&quot;</span></span><br></pre></td></tr></table></figure><br>之后我们删除这个文件并提交<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">rm -rf test.txt </span><br><span class="line"><span class="comment"># 将此文件的更改添加到缓存区</span></span><br><span class="line">git add test.txt</span><br><span class="line"><span class="comment"># 提交缓存区中的内容</span></span><br><span class="line">git commit -m <span class="string">&quot;update:删除测试文件&quot;</span></span><br></pre></td></tr></table></figure><br>此时查看日志<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以一行的方式显示最后的两次提交</span></span><br><span class="line">git <span class="built_in">log</span> --online -2</span><br></pre></td></tr></table></figure><br>得到以下输出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5be7df0 update:删除测试文件</span><br><span class="line">ac69d69 update:添加了一个测试文件</span><br></pre></td></tr></table></figure><br>这就意味着虽然你删除了文件，但是这个文件依然在 git 的日志中，可以进行恢复。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检出 ac69d69 版本时的 test.txt 文件</span></span><br><span class="line">git checkout ac69d69 -- test.txt</span><br></pre></td></tr></table></figure><br>但是有的时候我们可能并不希望删除的文件被恢复，比如说一不小心提交了一些没用的测试文件，显然是不希望永远的放在 git 记录中的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch --index-filter <span class="string">&quot;git rm -rf --cached --ignore-unmatch test.txt&quot;</span> HEAD</span><br></pre></td></tr></table></figure></p>
<p>运行 filter-branch 时 Git 往 .git/refs/original 添加的一些 refs 中仍有对它的引用，因此需要将这些引用删除。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf .git/refs/original/</span><br></pre></td></tr></table></figure><br>删除没必要的 <code>reflog</code> 信息，然后清理不必要的文件并优化本地存储库<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog expire --all</span><br><span class="line">git gc --aggressive --prune</span><br></pre></td></tr></table></figure><br>最后删除空的提交日志<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch --prune-empty</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：这样操作会改写 <code>commit</code> 记录，所以如果已提交到服务端，请务必谨慎操作！如果确定没有问题可以使用下面的命令强制提交。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><br>如果当前为<code>master</code>分支或者被设为<code>proteced</code>则需要首先取消<code>proteced</code>。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git操作</tag>
      </tags>
  </entry>
  <entry>
    <title>展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告</title>
    <url>/good-advice-for-young-people/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告<br>走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。</p>
<p><strong>一位不知姓名的前辈</strong></p>

</blockquote>
<h1 id="自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。"><a href="#自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。" class="headerlink" title="自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。"></a>自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。</h1><p>由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个程序的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。<span id="more"></span><br>特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。</p>
<h1 id="不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。"><a href="#不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。" class="headerlink" title="不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。"></a>不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。</h1><p>这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢被偷了。</p>
<h1 id="这年代外语、学历、职称、驾驶证还是蛮重要的。"><a href="#这年代外语、学历、职称、驾驶证还是蛮重要的。" class="headerlink" title="这年代外语、学历、职称、驾驶证还是蛮重要的。"></a>这年代外语、学历、职称、驾驶证还是蛮重要的。</h1><p>想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。<br>学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。<br>若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。</p>
<h1 id="不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。"><a href="#不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。" class="headerlink" title="不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。"></a>不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。</h1><p>我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。</p>
<h1 id="工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。"><a href="#工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。" class="headerlink" title="工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。"></a>工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。</h1><p>换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。</p>
<h1 id="要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。"><a href="#要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。" class="headerlink" title="要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。"></a>要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。</h1><p>有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。<br>现在你身边的人有可能在不久的将来，给你提供很多好机会。</p>
<h1 id="钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。"><a href="#钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。" class="headerlink" title="钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。"></a>钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。</h1><p>钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。</p>
<h1 id="工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。"><a href="#工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。" class="headerlink" title="工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。"></a>工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。</h1><p>时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。</p>
<h1 id="每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。"><a href="#每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。" class="headerlink" title="每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。"></a>每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。</h1><p>总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。</p>
<h1 id="对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。"><a href="#对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。" class="headerlink" title="对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。"></a>对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。</h1><p>我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。</p>
<h1 id="当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。"><a href="#当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。" class="headerlink" title="当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。"></a>当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。</h1><p>我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle， 你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。<br>年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。</p>
<h1 id="当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。"><a href="#当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。" class="headerlink" title="当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。"></a>当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。</h1><p>创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。<br>不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。<br>其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。</p>
<h1 id="未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。"><a href="#未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。" class="headerlink" title="未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。"></a>未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。</h1><p>在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。</p>
<blockquote>
<p>原文地址:<a href="http://www.verycd.com/topics/93279/#theCom">http://www.verycd.com/topics/93279/#theCom</a><br>转载地址:<a href="https://github.com/glossary95/tt/blob/master/a1.md">https://github.com/glossary95/tt/blob/master/a1.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>鸡汤</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>深入研究CSS字体度量及CSS 盒子</title>
    <url>/in-depth-study-font-size-line-height-and-vertical-align/</url>
    <content><![CDATA[<p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/banner.png" alt="头图"></p>
<p>这张图展示的是8种不同的字体，其中第一、第二个分别为 <a href="https://github.com/FortAwesome/Font-Awesome/tree/v4.7.0">font-awesome</a>图标、自定义的字体图标，其余字体依次为<code>Avenir</code>、<code>Trebuchet MS</code>、<code>Arial</code>、<code>Helvetica</code>、<code>Hiragino Sans GB</code>、<code>STXihei</code>。<a href="https://codepen.io/hiyangguo/pen/VXqQMB">源代码在这里</a>。这些字符的<code>font-size:100px</code>，但是占的高度却不一样。有的是 100px，有的大于 100px。另外可以看出，垂直方向并没有居中对齐。<br>这篇文章主要研究：</p>
<ul>
<li><code>font</code> 的工作原理及度量参数</li>
<li><code>CSS box models</code> 的类型、定义</li>
</ul>
<span id="more"></span>
<h2 id="字体度量"><a href="#字体度量" class="headerlink" title="字体度量"></a>字体度量</h2><p>要弄明白上面问题的答案，需要先从字体说起：<br>我们拿出其中<code>Avenir</code>、<code>Helvetica</code>、<code>Hiragino Sans GB</code>三种字体进行分析<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/font-detail.png" alt="字体占行高"><br>由上图可知，在我们设置 <code>font-size:100px</code> 时，文字所占的高度分别为 <code>137px</code>、 <code>115px</code> 和 <code>100px</code>。<br>感觉有点懵啊。怎么 <code>font-size:100px</code> ，可是高度却由于字体不同，而不一样了呢？<br>在字体设计中一个字符所在的空间容器称为<a href="https://designwithfontforge.com/zh-CN/The_EM_Square.html">EM Square</a>（也被称作“EM size”或者“UPM”）。</p>
<blockquote>
<p>在传统的金属字模中，这个容器就是每个字符的实际金属块。每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。</p>
</blockquote>
<p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/metal-type-zoom-in.jpg" alt="传统的金属字模"></p>
<h3 id="字体的定义规则"><a href="#字体的定义规则" class="headerlink" title="字体的定义规则"></a>字体的定义规则</h3><ul>
<li>字母的高度被称为“<code>em</code>”，在数字化字体中 <code>em</code> 是空间的数字化定义总量。<code>em</code>的大小（以下均写为: <strong>EM size</strong>）通常是 <strong>1000</strong> 单位，在 TrueType 字体中，<code>EM size</code> 约定是2的幂，通常是1024或2048。</li>
<li>根据其实际使用的单位，字体的度量可以根据一些<a href="./#字体的设置">设置</a>来决定。注意，有些值是em-square之外的值。</li>
<li>在浏览器中，相对单位是用于缩放用来适应所需的 <code>font-size</code></li>
</ul>
<h3 id="字体的设置"><a href="#字体的设置" class="headerlink" title="字体的设置"></a>字体的设置</h3><p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/font-metrics.jpg" alt="字体的设置"><br>这是一张详解字体设置的图例，图中各个属性的意义：</p>
<ul>
<li><code>baseline</code> (<em>基线</em>): 分隔 <code>ascent</code> 和 <code>descent</code> ，默认字符底端沿 <code>baseline</code> 排列，如图中的P，x，Ё(为俄文字符)</li>
<li><code>ascent</code> (<em>上升</em>): 基线的上部分，字符最高处与 <code>ascent</code> 顶端可能有空白，由 <code>font-family</code> 决定</li>
<li><code>descent</code> (<em>下降</em>): 基线的下部分，字符最低处与 <code>descent</code> 底端可能有空白，由 <code>font-family</code> 决定</li>
<li><code>xHeight</code> (<em>X 字高</em>): 小写字符 <strong>x</strong> 的高度，由 <code>font-family</code> 决定</li>
<li><code>capHeight</code> (<em>顶面高度</em>): 大些字符 <strong>P</strong> 的高度，由 <code>font-family</code> 决定</li>
<li><code>lineSpacing</code> (<em>行间距</em>): 在浏览器中一般 <code>lineSpacing = ascent + descent</code></li>
<li><code>lineHeight</code> （<em>行高</em>）: 默认等于 <code>lineSpacing</code>，受 <code>line-height</code> 设置影响，如果设置 <code>line-height</code>，<code>lineHeight</code> 等于 <code>line-height</code>。</li>
<li><code>half-leading</code> (<em>半行距</em>): 如果<code>lineHeight &gt; lineSpacing</code>，则<code>lineHeight</code> 与 <code>lineSpacing</code> 之间会产生<strong>上下相等</strong>的空隙 (lineHeight - lineSpacing)/2 称为<em>半行距</em>（<code>half-leading</code>或 <code>half lead strips</code>）。</li>
</ul>
<h3 id="字符所占高度的计算"><a href="#字符所占高度的计算" class="headerlink" title="字符所占高度的计算"></a>字符所占高度的计算</h3><p>所以在了解了上面的概念以后，就可以解答为什么在 <code>font-size:100px</code> 的时候行高却不一样的问题。<br>首先，先下载一个专业的字体软件<a href="https://fontforge.github.io/en-US/">FontForge</a>，这个软件运行在<a href="https://www.xquartz.org/">xquartz</a>上，所以要两个都要装。</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1GqI-n39GkFQWsNZ8vWKMGg">百度云通道</a></p>
</blockquote>
<p>安装后我们以 <a href="https://github.com/hiyangguo/hiyangguo.github.io/raw/dev/source/uploads/in-depth-study-font-size-line-height-and-vertical-align/Avenir.ttf">Avenir</a> 字体为例进行分析。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/avenir-detial-screenshots.png" alt="Avenir 字体详情截屏"></p>
<ul>
<li><code>EM size</code> 为 <strong>1000</strong> </li>
<li><code>ascent</code> 为 <strong>1000</strong> ，<code>descent</code> 为 <strong>366</strong></li>
<li><code>capHeight</code> 为 <strong>708</strong></li>
<li><code>xHeight</code> 为 <strong>468</strong></li>
</ul>
<blockquote>
<p>注：浏览器使用HHead Ascent/Descent值（Mac）和Win Ascent/Descent值（Windows），并且这些值可能不同。</p>
</blockquote>
<p>这意味着 <code>Avenir</code> 字体在 1000 单位的 <code>EM size</code> 中使用了 <code>1000 + 366</code> 个单位，也就是说 <code>font-size:100px</code>，其高度为 <code>100px * (1000 + 366 ) ≈ 137px</code>。<br>这个计算高度定义了 <strong><a href="#Content-area">元素内容（Content area）</a>高度</strong> 也就相当于 <code>background</code> 属性。</p>
<p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/avenir-analysis.png" alt="Avenir 字体解析图"></p>
<h2 id="CSS-box-models"><a href="#CSS-box-models" class="headerlink" title="CSS box models"></a>CSS box models</h2><p>接下来我们深入的研究一下，<code>CSS box models</code>。你可能不知道什么<code>CSS box models</code>，不过说出来你可能不信，在实际工作当中恐怕你最常见的就是<code>CSS box models</code>。</p>
<h3 id="Block-Box-Containing-Box-块盒子-包裹盒子"><a href="#Block-Box-Containing-Box-块盒子-包裹盒子" class="headerlink" title="Block Box/Containing Box (块盒子/包裹盒子)"></a>Block Box/Containing Box (块盒子/包裹盒子)</h3><p>比如有一段简单的文字，就有可能会有一些列的 <code>box</code> 。那么这个段落被称为 <strong><code>Containing Box</code></strong> ，之所以这么命名，可能是因为他包含了很多 <code>box</code>  吧。（呵…）当然你也可以称之为 <strong><code>Block Box</code></strong>，因为他就是一个<strong>块</strong>。简单来说<code>Containing Box</code>和<code>Block Box</code>其实是一个东西。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/block-box-demo.png" alt="Block Box演示"></p>
<h3 id="Inline-Box-内联盒子"><a href="#Inline-Box-内联盒子" class="headerlink" title="Inline Box (内联盒子)"></a>Inline Box (内联盒子)</h3><p>在段落内部，有很多的 <strong><code>Inline Box</code></strong>。 这些 <code>Box</code> 不会像 <code>Block Box</code> 那样形成新的一⾏。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/inline-box-demo.png" alt="Inline Box演示"><br>在上面的例子中, <code>&lt;em/&gt;</code> 标签包裹的 <em>斜体元素</em> 就是一个典型的 <code>Inline Box</code>。</p>
<h3 id="Anonymous-Inline-Box-匿名内联盒子"><a href="#Anonymous-Inline-Box-匿名内联盒子" class="headerlink" title="Anonymous Inline Box (匿名内联盒子)"></a>Anonymous Inline Box (匿名内联盒子)</h3><p>在段落内部，那些没有标记的<code>Inline Box</code> 则成为 <strong><code>Anonymous inline Box</code></strong>。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/anonymous-box-demo.png" alt="Anonymous Inline Box演示"></p>
<h3 id="Line-Box-行盒子"><a href="#Line-Box-行盒子" class="headerlink" title="Line Box (行盒子)"></a>Line Box (行盒子)</h3><p>所有<code>Inline Box</code>在<code>Containing Box</code>紧挨着排列，则会形成 <strong><code>Line Box</code></strong>。需要注意的是，<code>Line Box</code>是没办法直观看到的。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-demo.png" alt="Line Box演示"></p>
<h3 id="Content-area"><a href="#Content-area" class="headerlink" title="Content area"></a>Content area</h3><p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/content-area.png" alt="Content area"><br><strong><code>Content area</code></strong> 是围绕⽂文本的<em>隐形框</em>。 而且在字体度量这一小节我们也证明过了，它的高度由<code>font-size</code>决定。</p>
<blockquote>
<p>更详细的定义及说明可以访问 CSS 规范2.1 中关于 <strong>视觉格式化模型</strong>（<em>Visual formatting model</em>）一节进行阅读。<br><a href="http://www.ayqy.net/doc/css2-1/visuren.html">中文站</a>|<a href="https://www.w3.org/TR/CSS2/visuren.html">W3C 官网</a></p>
</blockquote>
<h2 id="Inline-Box-与-Line-Box"><a href="#Inline-Box-与-Line-Box" class="headerlink" title="Inline Box 与 Line Box"></a><code>Inline Box</code> 与 <code>Line Box</code></h2><h3 id="Inline-Box-如何影响-Line-Box"><a href="#Inline-Box-如何影响-Line-Box" class="headerlink" title="Inline Box 如何影响 Line Box"></a>Inline Box 如何影响 Line Box</h3><p><code>Line box</code> 的高度由 <code>Line Box</code> 中最⾼的 <code>Inline Box</code>（或<code>Replaced Element</code>）确定。<br>最⾼的 <code>Inline Box</code> 可以是⼀个 <code>Anonymous Inline Box</code>。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-with-anonymous-Inline-box.png" alt="line-box-with-anonymous-Inline-box"></p>
<p>也可能是一个增加了<code>line-height</code>的 <code>Inline Box</code>。 由于增加了 <code>line-height</code> ，所以这个它会比其它的 <code>box</code> 更高。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-with-increased-Inline-box.png" alt="line-box-with-increased-Inline-box"></p>
<p>可能是⼀个更⼤的 <code>font-size</code> 的 <code>Inline Box</code>，这使得这个 <code>Inline Box</code> ⽐其他 <code>Inline Box</code> 更高。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-with-increased-font-size.png" alt="line-box-with-increased-font-size"></p>
<p>由于浏览器器的不同，它也可能受到上标或下标的影响。 因为有些浏览器以影响<code>Line box</code>的方式渲染上标元素。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-with-superscript-inline-box.png" alt="line-box-with-superscript-inline-box"></p>
<p>我们可以通过设置 <code>&lt;sup/&gt;</code>、<code>&lt;sub/&gt;</code> 的 <code>line-height</code> 为 0 来解决这个问题。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">sub, <span class="selector-tag">sup</span> &#123; <span class="attribute">line-height</span>: <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Inline Box</code> 可能受到 <code>Replaced Element</code>（如：<code>&lt;img/&gt;</code>、<code>&lt;input/&gt;</code>、<code>&lt;svg/&gt;</code>） 的影响。</p>
<p><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-with-replaced-element.png" alt="line-box-with-replaced-element"></p>
<h3 id="Inline-Box-撑破-Line-Box"><a href="#Inline-Box-撑破-Line-Box" class="headerlink" title="Inline Box 撑破 Line Box"></a>Inline Box 撑破 Line Box</h3><p>正如我们所看到的, <code>Line Box</code> 将增加所有行内 <code>Inline Box</code> 的⾼度。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/line-box-addtional-inline-box-height.png" alt="line-box-addtional-inline-box-height"><br>但是，有时候 <code>Inline Box</code> 的一部分会撑破 <code>Line Box</code> 的顶部或底部。例如一个拥有<code>padding</code>、<code>margin</code>、<code>border</code> 的 <code>Inline Box</code> 。由于 <code>Inline Box</code> 不能设定高度（设了也白设）。因此会在元素的上方和下方显示<code>padding</code>、<code>margin</code>、<code>border</code>，但并不会影响 <code>Line Box</code>。<br><strong>注意</strong>：对于<code>Replaced Element</code>、<code>inline-block</code>行内元素<code>padding</code>、<code>margin</code>、<code>border</code>都会增加高度，所以<code>Line Box</code> 的高度也会受到影响。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/inline-box-poke-out-line-box.png" alt="inline-box-poke-out-line-box"><br>浏览器将按照文档的先后顺序呈现 <code>Line Box</code>。 所以, 后续行上的 <code>border</code> 可能会覆盖上⼀行的 <code>border</code>和文本。<br><img src="/uploads/in-depth-study-font-size-line-height-and-vertical-align/pants-over-prvious-line.png" alt="pants-over-previous-line"></p>
<blockquote>
<p>参考文章<br><a href="https://yoution.gitbooks.io/webkit/Layout/InlineElement-Vertical/">行内元素垂直方向的layout</a><br><a href="https://www.w3cplus.com/css/css-font-metrics-line-height-and-vertical-align.html">深入了解CSS字体度量，行高和vertical-align</a><br><a href="https://designwithfontforge.com/zh-CN/The_EM_Square.html">FontForge 与字体设计 - EM Square</a><br><a href="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/deep-dive-line-height.pdf">Deep dive line-height</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centos 安装 docker</title>
    <url>/install-docker-on-centos/</url>
    <content><![CDATA[<h2 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h2><p>本文以 centos7 为例。记录了完整的安装命令。</p>
<span id="more"></span>
<h3 id="切换-root-用户"><a href="#切换-root-用户" class="headerlink" title="切换 root 用户"></a>切换 root 用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure>
<p>必须为 centos7 或者 centos8 ，遗产版本不能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<h3 id="更新-yum-包"><a href="#更新-yum-包" class="headerlink" title="更新 yum 包"></a>更新 yum 包</h3><p>生产环境慎重执行。如果在生产环境，请谨慎操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure>
<h3 id="卸载旧的-docker"><a href="#卸载旧的-docker" class="headerlink" title="卸载旧的 docker"></a>卸载旧的 docker</h3><p>如果机器上有老版本的 docker 建议卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="使用仓库安装"><a href="#使用仓库安装" class="headerlink" title="使用仓库安装"></a>使用仓库安装</h3><p>安装必要的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
<p>设置一个源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h4 id="普通安装"><a href="#普通安装" class="headerlink" title="普通安装"></a>普通安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p>安装成功后结果如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqtun8xjy5j319a08sgmy.jpg" alt="执行结果"></p>
<h4 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h4><p>查询可用的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="comment"># 第二列是版本号</span></span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable</span><br></pre></td></tr></table></figure>
<p>安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-&lt;版本号&gt; docker-ce-cli-&lt;版本号&gt; containerd.io</span><br></pre></td></tr></table></figure></p>
<p>启动 docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker<span class="comment">## 设置开机自启systemctl enable docker</span></span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<p>可以看到 docker 的版本号就是好了</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqtupxojh1j30im02caab.jpg" alt="执行结果"></p>
<blockquote>
<p>参考<br><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>less换肤功能实践</title>
    <url>/less-multiple-color-theme-realize/</url>
    <content><![CDATA[<p>在我司的后台管理组件库<a href="http://pagurain.com">pagurain</a>、<a href="http://rsuite.github.io">rsuite</a>中要求实现换肤功能，以下是我们对这一功能实践的记录及过程。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>为了统一各产品的视觉和操作体验，我们建立了<a href="http://pagurian.com/design/index.html">UI规范体系</a>，方便创建项目也方便统一管理。<br>以扁平化和简洁为主旨的设计风格，使用块面来进行布局，用线条来表达各个控件，使功能庞杂的系统 既直观又条理清晰，让使用者一目了然。</p>
<h3 id="主色及色阶"><a href="#主色及色阶" class="headerlink" title="主色及色阶"></a>主色及色阶</h3><p>系统共用的组件颜色和变化形式是统一的，在此基础上，各系统又有自己的主色调。</p>
<p>每套系统都会有一个主色，并在主色的基础上，在同一色调中扩充成一组完整的可复用的色彩体系，丰富系统配色。</p>
<p>如下图所示，每组色彩是按一定的规律在明度和饱和度上选取得出的。</p>
<p><img src="/uploads/14900858020010.jpg" alt=""></p>
<span id="more"></span>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>按照上面的实现，我们的多套皮肤就是先定义一个主色 <code>@H500</code>，然后使用 <code>@H500</code> 这个颜色计算出其他的颜色，就搞定了。每次在不同的主题就换一套颜色。当然最终还是要生成多套颜色的<code>css</code>。<br>下面就按照这个思路开始吧。首先，我们按照设计师的要求定义一组颜色，如下：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@H050:</span><span class="number">#e8f4ee</span>;</span><br><span class="line"><span class="variable">@H100:</span><span class="number">#bbdfcb</span>;</span><br><span class="line"><span class="variable">@H200:</span><span class="number">#8dcaa8</span>;</span><br><span class="line"><span class="variable">@H300:</span><span class="number">#67b88b</span>;</span><br><span class="line"><span class="variable">@H400:</span><span class="number">#41a66e</span>;</span><br><span class="line"><span class="variable">@H500:</span><span class="number">#1b9451</span>;</span><br><span class="line"><span class="variable">@H600:</span><span class="number">#188247</span>;</span><br><span class="line"><span class="variable">@H700:</span><span class="number">#146f3d</span>;</span><br><span class="line"><span class="variable">@H800:</span><span class="number">#115d33</span>;</span><br><span class="line"><span class="variable">@H900:</span><span class="number">#0e4a29</span>;</span><br></pre></td></tr></table></figure><br>这组颜色的计算规则如下:<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@H050:</span>darken(<span class="variable">@H500</span>,<span class="number">90%</span>);</span><br><span class="line"><span class="variable">@H100:</span>darken(<span class="variable">@H500</span>,<span class="number">70%</span>);</span><br><span class="line"><span class="variable">@H200:</span>darken(<span class="variable">@H500</span>,<span class="number">50%</span>);</span><br><span class="line"><span class="variable">@H300:</span>darken(<span class="variable">@H500</span>,<span class="number">33.3%</span>);</span><br><span class="line"><span class="variable">@H400:</span>darken(<span class="variable">@H500</span>,<span class="number">16.6%</span>);</span><br><span class="line"><span class="variable">@H500:</span><span class="number">#1b9451</span>;</span><br><span class="line"><span class="variable">@H600:</span>lighten(<span class="variable">@H500</span>,<span class="number">12.5%</span>);</span><br><span class="line"><span class="variable">@H700:</span>lighten(<span class="variable">@H500</span>,<span class="number">25%</span>);</span><br><span class="line"><span class="variable">@H800:</span>lighten(<span class="variable">@H500</span>,<span class="number">37.5%</span>);</span><br><span class="line"><span class="variable">@H900:</span>lighten(<span class="variable">@H500</span>,<span class="number">50%</span>);</span><br></pre></td></tr></table></figure><br>这猛一看挺简单啊，颜色的计算规则也有了，<code>less</code>也有相应的函数，这不很简单么。直接一算就出来了。<br>结果呢：</p>
<p>先用个绿色(<code>#1b9451</code>)试试</p>
<p><img src="/uploads/14900876640259.jpg" alt=""></p>
<p>换个蓝色(<code>#b3d1ff</code>)呢<br><img src="/uploads/14900876785104.jpg" alt=""></p>
<p>结果发现，如果颜色太深，那么<code>darken</code>后的颜色就是一堆黑色，如果颜色偏浅，那<code>lighten</code>后的颜色就是一堆白色。所以显然，使用<code>less</code>自带的颜色函数式不行的。那怎么办呢？<br>最简单的方法就是，现在外面算好了再复制进来，每次都复制10个颜色。计算颜色的方法，如下:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Color utility functions</span></span><br><span class="line"><span class="comment"> * Source: http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors</span></span><br><span class="line"><span class="comment"> * Github: https://github.com/mbitson/mcg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shadeColor</span>(<span class="params">color, percent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="built_in">parseInt</span>(color.slice(<span class="number">1</span>), <span class="number">16</span>),</span><br><span class="line">        t = percent &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">255</span>,</span><br><span class="line">        p = percent &lt; <span class="number">0</span> ? percent * -<span class="number">1</span> : percent,</span><br><span class="line">        R = f &gt;&gt; <span class="number">16</span>,</span><br><span class="line">        G = f &gt;&gt; <span class="number">8</span> &amp; <span class="number">0x00FF</span>,</span><br><span class="line">        B = f &amp; <span class="number">0x0000FF</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + (<span class="number">0x1000000</span> + (<span class="built_in">Math</span>.round((t - R) * p) + R) * <span class="number">0x10000</span> + (<span class="built_in">Math</span>.round((t - G) * p) + G) * <span class="number">0x100</span> + (<span class="built_in">Math</span>.round((t - B) * p) + B)).toString(<span class="number">16</span>).slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为此我们还特意做了一个页面来方便使用,<a href="http://pagurian.com/demo/dist/templates/theme-color.html">页面链接</a><br>这样一来最起码的颜色就有了，我们只需先用这些变量生成一套基础的主题<code>base.less</code>，然后分别创建多个主题文件的<code>green.less</code>、<code>blue.less</code>，再分别覆盖这10个颜色变量，然后<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;base&quot;</span>; <span class="comment">//按照less 语法import less 可以省略文件ext</span></span><br></pre></td></tr></table></figure><br>最终就可以得到多套<code>css</code>了。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="一次只传一个颜色"><a href="#一次只传一个颜色" class="headerlink" title="一次只传一个颜色"></a>一次只传一个颜色</h3><p>仅仅是那样，用肯定是没问题了，但是每次使用都要去生成配色的页面生成颜色，用着着实不爽。于是乎就想着能不能够有什么方法，自己去定义一个方法在less里直接调用。最终发现<code>grunt-contrib-less</code>这个插件有一个<code>customFunctions</code>方法,可以实现自定义方法，所以改进了一下。而且可以覆盖原有的变量，所以改进了一下，得到了如下代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成主题</span></span><br><span class="line">grunt.registerTask(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;Generate theme&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(themes).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> color = themes[name];</span><br><span class="line">        <span class="keyword">const</span> taskName = <span class="string">`theme-<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> outputName = <span class="string">`src/resources/css/themes-<span class="subst">$&#123;name&#125;</span>.css`</span>;</span><br><span class="line">        grunt.config.merge(&#123;</span><br><span class="line">            less: &#123;</span><br><span class="line">                [taskName]: &#123;</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        customFunctions: &#123;</span><br><span class="line">                            pallet</span><br><span class="line">                        &#125;,</span><br><span class="line">                        modifyVars: &#123;</span><br><span class="line">                            <span class="string">&#x27;base-color&#x27;</span>: color</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    files: &#123;</span><br><span class="line">                        [outputName]: <span class="string">&#x27;src/resources/less/theme/base.less&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        grunt.task.run(<span class="string">`less:<span class="subst">$&#123;taskName&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><a href="https://github.com/hypers/pagurian/blob/dev/Gruntfile.js">源代码地址</a>;</p>
<h3 id="扔掉grunt"><a href="#扔掉grunt" class="headerlink" title="扔掉grunt"></a>扔掉<code>grunt</code></h3><p>但是这个时候问题又来了，因为这样做的话，就只能用<code>grunt</code>进行构建了，<code>gulp</code>构建或者<code>webpack</code>打包肯定不行啊（没有pallet方法）,那怎么办呢。一个<a href="https://github.com/ant-design/ant-design/blob/734beb84ffc3f0469fbae1566aa8450f966cb261/components/style/color/colorPalette.less">偶然发现</a>使用less中的转义语法 <strong>~<code></code></strong> 居然可以执行js。简直了。然后经过测试使用这种hack方法可以成功的定义function，就解决了一切问题.<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.colorPaletteMixin</span> &#123;</span><br><span class="line">    <span class="variable">@functions:</span> ~`(function () &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Color utility functions</span></span><br><span class="line"><span class="comment">     * Source: http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors</span></span><br><span class="line"><span class="comment">     * Github: https://github.com/mbitson/mcg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    var shadeColor = function (<span class="attribute">color</span>, percent) &#123;</span><br><span class="line">        var f = parseInt(<span class="attribute">color</span>.slice(<span class="number">1</span>), <span class="number">16</span>),</span><br><span class="line">            t = percent &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">255</span>,</span><br><span class="line">            p = percent &lt; <span class="number">0</span> ? percent * <span class="attribute">-1 </span>: percent,</span><br><span class="line">            R = f &gt;&gt; <span class="number">16</span>,</span><br><span class="line">            G = f &gt;&gt; <span class="number">8</span> &amp; <span class="number">0</span>x00FF,</span><br><span class="line">            B = f &amp; <span class="number">0</span>x0000FF;</span><br><span class="line">        return <span class="string">&quot;#&quot;</span> + (<span class="number">0</span>x1000000 + (Math.round((t - R) * p) + R) * <span class="number">0</span>x10000 + (Math.round((t - G) * p) + G) * <span class="number">0</span>x100 + (Math.round((t - B) * p) + B)).toString(<span class="number">16</span>).slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算系统颜色</span></span><br><span class="line"><span class="comment">     * @param color</span></span><br><span class="line"><span class="comment">     * @param percent (正值表示lighter,负值表示darken)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    this.pallet = function (<span class="attribute">color</span>, percent) &#123;</span><br><span class="line">        var colorConfig = &#123;</span><br><span class="line">            <span class="string">&#x27;50&#x27;</span>: <span class="number">0.9</span>,</span><br><span class="line">            <span class="string">&#x27;100&#x27;</span>: <span class="number">0.7</span>,</span><br><span class="line">            <span class="string">&#x27;200&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;300&#x27;</span>: <span class="number">0.333</span>,</span><br><span class="line">            <span class="string">&#x27;400&#x27;</span>: <span class="number">0.166</span>,</span><br><span class="line">            <span class="string">&#x27;500&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;600&#x27;</span>: -<span class="number">0.125</span>,</span><br><span class="line">            <span class="string">&#x27;700&#x27;</span>: -<span class="number">0.25</span>,</span><br><span class="line">            <span class="string">&#x27;800&#x27;</span>: -<span class="number">0.375</span>,</span><br><span class="line">            <span class="string">&#x27;900&#x27;</span>: -<span class="number">0.5</span></span><br><span class="line">        &#125;;</span><br><span class="line">        percent = colorConfig[percent] === undefined ? <span class="attribute">percent </span>: colorConfig[percent] ;</span><br><span class="line">        <span class="attribute">color</span> = <span class="attribute">color</span>.toLowerCase();</span><br><span class="line">        return shadeColor(<span class="attribute">color</span>, percent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()`;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// It is hacky way to make this function will be compiled preferentially by less</span></span><br><span class="line"><span class="selector-class">.colorPaletteMixin</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后我只想说，写好文档太重要了，这里各种的坑，简直是踩也踩不完。说多了都是泪。安利一下我司的<code>react</code>组件库<a href="http://rsuite.github.io/">rsuite</a>。l</p>
]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>less</tag>
        <tag>grunt</tag>
        <tag>多主题</tag>
      </tags>
  </entry>
  <entry>
    <title>全面解析Module模式</title>
    <url>/module-pattern/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Module模式是JavaScript编程中一个非常通用的模式，一般情况下，大家都知道基本用法，本文尝试着给大家更多该模式的高级使用方式。</p>
<p>首先我们来看看Module模式的基本特征：</p>
<ol>
<li>模块化，可重用</li>
<li>封装了变量和<code>function</code>，和全局的namaspace不接触，解耦合</li>
<li>只暴露可用public的方法，其它私有方法全部隐藏</li>
</ol>
<p>关于Module模式，最早是由YUI的成员Eric Miraglia在4年前提出了这个概念，我们将从一个简单的例子来解释一下基本的用法（如果你已经非常熟悉了，请忽略这一节）。</p>
<span id="more"></span>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>先看一下最简单的一个实现，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> (<span class="params">eq</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以声明私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> eqCtl = <span class="built_in">document</span>.getElementById(eq);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 暴露公开的成员</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> val = x + y;</span><br><span class="line">            eqCtl.innerHTML = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以通过如下的方式来调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = <span class="keyword">new</span> Calculator(<span class="string">&#x27;eq&#x27;</span>);</span><br><span class="line">calculator.add(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>大家可能看到了，每次用的时候都要new一下，也就是说每个实例在内存里都是一份copy，如果你不需要传参数或者没有一些特殊苛刻的要求的话，我们可以在最后一个}后面加上一个括号，来达到自执行的目的，这样该实例在内存中只会存在一份copy，不过在展示他的优点之前，我们还是先来看看这个模式的基本使用方法吧。</p>
<h2 id="匿名闭包"><a href="#匿名闭包" class="headerlink" title="匿名闭包"></a>匿名闭包</h2><p>==匿名闭包==是让一切成为可能的基础，而这也是<code>JavaScript</code>最好的特性，我们来创建一个最简单的闭包函数，函数内部的代码一直存在于闭包内，在整个运行周期内，该闭包都保证了内部的代码处于私有状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 所有的变量和function都在这里声明，并且作用域也只能在这个匿名闭包里</span></span><br><span class="line">    <span class="comment">// ...但是这里的代码依然可以访问外部全局的对象</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>注意，匿名函数后面的括号，这是JavaScript语言所要求的，因为如果你不声明的话，JavaScript解释器默认是声明一个function函数，有括号，就是创建一个函数表达式，也就是自执行，用的时候不用和上面那样在new了，当然你也可以这样来声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/* 内部代码 */</span>&#125;)();</span><br></pre></td></tr></table></figure>
<p>不过我们推荐使用第一种方式，关于函数自执行，我后面会有专门一篇文章进行详解，这里就不多说了。</p>
<h2 id="引用全局变量"><a href="#引用全局变量" class="headerlink" title="引用全局变量"></a>引用全局变量</h2><p>JavaScript(非严格模式下)有一个特性叫做隐式全局变量，不管一个变量有没有用过，JavaScript解释器反向遍历作用域链来查找整个变量的var声明，如果没有找到var，解释器则假定该变量是全局变量，如果该变量用于了赋值操作的话，之前如果不存在的话，解释器则会自动创建它，这就是说在匿名闭包里使用或创建全局变量非常容易，不过比较困难的是，代码比较难管理，尤其是阅读代码的人看着很多区分哪些变量是全局的，哪些是局部的。</p>
<p>不过，好在在匿名函数里我们可以提供一个比较简单的替代方案，我们可以将全局变量当成一个参数传入到匿名函数然后使用，相比隐式全局变量，它又清晰又快，我们来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</span></span><br><span class="line">&#125; (jQuery, YAHOO));</span><br></pre></td></tr></table></figure>
<p>现在很多类库里都有这种使用方式，比如jQuery源码。</p>
<p>不过，有时候可能不仅仅要使用全局变量，而是也想声明全局变量，如何做呢？我们可以通过匿名函数的返回值来返回这个全局变量，这也就是一个基本的Module模式，来看一个完整的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> my = &#123;&#125;, privateName = <span class="string">&quot;segmentfault&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateAddTopic</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是内部处理代码</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    my.Name = privateName;</span><br><span class="line">    my.AddTopic = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        privateAddTopic(data);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure>
<p>上面的代码声明了一个全局变量blogModule，并且带有2个可访问的属性：blogModule.AddTopic和blogModule.Name，除此之外，其它代码都在匿名函数的闭包里保持着私有状态。同时根据上面传入全局变量的例子，我们也可以很方便地传入其它的全局变量。</p>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p>上面的内容对大多数用户已经很足够了，但我们还可以基于此模式延伸出更强大，易于扩展的结构，让我们一个一个来看。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>==Module模式==的一个限制就是所有的代码都要写在一个文件，但是在一些大型项目里，将一个功能分离成多个文件是非常重要的，因为可以多人合作易于开发。再回头看看上面的全局参数导入例子，我们能否把blogModule自身传进去呢？答案是肯定的，我们先将blogModule传进去，添加一个函数属性，然后再返回就达到了我们所说的目的，上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">    my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//添加内部代码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; (blogModule));</span><br></pre></td></tr></table></figure>
<p>这段代码，看起来是不是有C#里扩展方法的感觉？有点类似，但本质不一样哦。同时尽管var不是必须的，但为了确保一致，我们再次使用了它，代码执行以后，<code>blogModule</code>下的<code>AddPhoto</code>就可以使用了，同时匿名函数内部的代码也依然保证了私密性和内部状态。</p>
<h2 id="松耦合扩展"><a href="#松耦合扩展" class="headerlink" title="松耦合扩展"></a>松耦合扩展</h2><p>上面的代码尽管可以执行，但是必须先声明blogModule，然后再执行上面的扩展代码，也就是说步骤不能乱，怎么解决这个问题呢？我们来回想一下，我们平时声明变量的都是都是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cnblogs = cnblogs || &#123;&#125; ;</span><br></pre></td></tr></table></figure>
<p>这是确保cnblogs对象在存在的时候直接用，不存在的时候直接赋值为{}，我们来看看如何利用这个特性来实现Module模式的任意加载顺序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一些功能</span></span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; (blogModule || &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>通过这样的代码，每个单独分离的文件都保证这个结构，那么我们就可以实现任意顺序的加载，所以，这个时候的var就是必须要声明的，因为不声明，其它文件读取不到哦。</p>
<h2 id="紧耦合扩展"><a href="#紧耦合扩展" class="headerlink" title="紧耦合扩展"></a>紧耦合扩展</h2><p>虽然松耦合扩展很牛叉了，但是可能也会存在一些限制，比如你没办法重写你的一些属性或者函数，也不能在初始化的时候就是用Module的属性。紧耦合扩展限制了加载顺序，但是提供了我们重载的机会，看如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldAddPhotoMethod = my.AddPhoto;</span><br><span class="line"> </span><br><span class="line">    my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重载方法，依然可通过oldAddPhotoMethod调用旧的方法</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; (blogModule));</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们达到了重载的目的，当然如果你想在继续在内部使用原有的属性，你可以调用oldAddPhotoMethod来用。</p>
<h2 id="克隆与继承"><a href="#克隆与继承" class="headerlink" title="克隆与继承"></a>克隆与继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">old</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> my = &#123;&#125;,</span><br><span class="line">        key;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> old) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old.hasOwnProperty(key)) &#123;</span><br><span class="line">            my[key] = old[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> oldAddPhotoMethod = old.AddPhoto;</span><br><span class="line">    my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; (blogModule));</span><br></pre></td></tr></table></figure>
<p>这种方式灵活是灵活，但是也需要花费灵活的代价，其实该对象的属性对象或function根本没有被复制，只是对同一个对象多了一种引用而已，所以如果老对象去改变它，那克隆以后的对象所拥有的属性或function函数也会被改变，解决这个问题，我们就得是用递归，但递归对function函数的赋值也不好用，所以我们在递归的时候eval相应的function。不管怎么样，我还是把这一个方式放在这个帖子里了，大家使用的时候注意一下就行了。</p>
<h2 id="跨文件共享私有对象"><a href="#跨文件共享私有对象" class="headerlink" title="跨文件共享私有对象"></a>跨文件共享私有对象</h2><p>通过上面的例子，我们知道，如果一个module分割到多个文件的话，每个文件需要保证一样的结构，也就是说每个文件匿名函数里的私有对象都不能交叉访问，那如果我们非要使用，那怎么办呢？ 我们先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _private = my._private = my._private || &#123;&#125;,</span><br><span class="line">        _seal = my._seal = my._seal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">delete</span> my._private;</span><br><span class="line">            <span class="keyword">delete</span> my._seal;</span><br><span class="line">            <span class="keyword">delete</span> my._unseal;</span><br><span class="line">        &#125;,</span><br><span class="line">        _unseal = my._unseal = my._unseal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            my._private = _private;</span><br><span class="line">            my._seal = _seal;</span><br><span class="line">            my._unseal = _unseal;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; (blogModule || &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>任何文件都可以对他们的局部变量_private设属性，并且设置对其他的文件也立即生效。一旦这个模块加载结束，应用会调用 blogModule._seal()”上锁”，这会阻止外部接入内部的_private。如果这个模块需要再次增生，应用的生命周期内，任何文件都可以调用_unseal() ”开锁”，然后再加载新文件。加载后再次调用 _seal()”上锁”。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a><strong>子模块</strong></h2><p>最后一个也是最简单的使用方式，那就是创建子模块<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">blogModule.CommentSubModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> my = &#123;&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> my;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure></p>
<p>尽管非常简单，我还是把它放进来了，因为我想说明的是子模块也具有一般模块所有的高级使用方式，也就是说你可以对任意子模块再次使用上面的一些应用方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的大部分方式都可以互相组合使用的，一般来说如果要设计系统，可能会用到松耦合扩展，私有状态和子模块这样的方式。另外，我这里没有提到性能问题，但我认为Module模式效率高，代码少，加载速度快。使用松耦合扩展允许并行加载，这更可以提升下载速度。不过初始化时间可能要慢一些，但是为了使用好的模式，这是值得的。</p>
<p>参考文章：<br><a href="http://yuiblog.com/blog/2007/06/12/module-pattern/">http://yuiblog.com/blog/2007/06/12/module-pattern/</a><br><a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth</a></p>
<h1 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h1><p>本文转自<a href="http://www.cnblogs.com/TomXu">TOM大叔</a>的<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a></p>
<blockquote>
<p>【深入理解JavaScript系列】文章，包括了原创，翻译，转载，整理等各类型文章，原文是TOM大叔的一个非常不错的专题，现将其重新整理发布。谢谢大叔。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>纯CSS实现涟漪按钮效果</title>
    <url>/pure-css-ripple-button/</url>
    <content><![CDATA[<p><strong>涟漪按钮</strong>：顾名思义，就是点击按钮的时候，有一个圆圈扩散开来，就像水面的涟漪。效果如下：<br><img src="/uploads/14847466653424.gif" alt=""><br>看上去非常简单的效果，就是点击的时候一个圆圈从小变大，于此同时透明度从半透明变为透明。<br>常见的方式是使用<code>javascript</code>：</p>
<ol>
<li>监听鼠标的点击事件，当点击按钮的时候，追加一个圆形的<code>dom</code></li>
<li>改变<code>dom</code>的大小，直至完全覆盖按钮</li>
<li>移除按钮</li>
</ol>
<span id="more"></span>
<p>但是这个方法，有几个缺点：</p>
<ol>
<li>首先就是你要给按钮添加一个事件</li>
<li>然后添加，移除<code>dom</code>会造成页面的重绘</li>
<li>绘制的时候会要进行运算</li>
</ol>
<p>所以最终参考利用<code>:active</code>、<code>bacground</code>、<code>scale</code>实现了一个纯css的涟漪按钮效果。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button-ripple</span>() &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">transition</span>: background-color .<span class="number">3s</span> linear, border .<span class="number">3s</span> linear;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span>:<span class="selector-tag">after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">pointer-events</span>: none;</span><br><span class="line">        <span class="attribute">background-image</span>: radial-gradient(circle, <span class="number">#000</span> <span class="number">10%</span>, rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="number">10.01%</span>);</span><br><span class="line">        <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: scale(<span class="number">10</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transition</span>: transform .<span class="number">5s</span>, opacity <span class="number">1s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:active</span>:<span class="selector-tag">after</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: scale(<span class="number">0</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: .<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">transition</span>: <span class="number">0s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个<code>less</code>的<code>mixin</code>，在需要涟漪效果的地方直接使用即可，如:<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ripple</span>&#123;</span><br><span class="line">  <span class="selector-class">.button-ripple</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此方法的原理是:<br>首先在按钮的正中间利用<code>:after</code>伪元素画了一个遮罩（此遮罩刚好盖住整个按钮），当点击按钮的时候将遮罩缩小到0%，松开鼠标时，还原100%大小，并将透明度缩小到0。<br><a href="http://codepen.io/hiyangguo/pen/BpRRrz">Demo地址</a></p>
]]></content>
      <categories>
        <category>CSS黑魔法</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title>React 高阶组件浅析</title>
    <url>/react-hoc-simple-analysis/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>高阶组件的这种写法的诞生来自于社区的实践，目的是解决一些交叉问题(Cross-Cutting Concerns)。而最早时候 <code>React</code> 官方给出的解决方案是使用 <code>mixin</code> 。而 React 也在官网中写道：</p>
<blockquote>
<p>We previously recommended mixins as a way to handle cross-cutting concerns. We’ve since realized that mixins create more trouble than they are worth. </p>
</blockquote>
<p>官方明显也意识到了使用<code>mixins</code>技术来解决此类问题所带来的困扰远高于其本身的价值。<a href="https://react.bootcss.com/react/blog/2016/07/13/mixins-considered-harmful.html">更多资料</a>可以查阅官方的说明。</p>
<h2 id="高阶函数的定义"><a href="#高阶函数的定义" class="headerlink" title="高阶函数的定义"></a>高阶函数的定义</h2><p>说到高阶组件，就不得不先简单的介绍一下高阶函数。下面展示一个最简单的高阶函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y,f</span>) =&gt;</span> f(x)+f(y)</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数 x，y 和f 分别接收 -5，6 和 <code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D;&#x3D;&gt; -5</span><br><span class="line">y &#x3D;&#x3D;&gt; 6</span><br><span class="line">f &#x3D;&#x3D;&gt; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; Math.abs(-5) + Math.abs(6) &#x3D;&#x3D;&gt; 11</span><br></pre></td></tr></table></figure><br>用代码验证一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(-<span class="number">5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs); <span class="comment">//11</span></span><br></pre></td></tr></table></figure><br>高阶在维基百科的定义如下</p>
<blockquote>
<p>高阶函数是至少满足下列一个条件的函数：</p>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
</blockquote>
<h2 id="高阶组件的定义"><a href="#高阶组件的定义" class="headerlink" title="高阶组件的定义"></a>高阶组件的定义</h2><p>那么，什么是高阶组件呢？类比高阶函数的定义，<strong>高阶组件就是接受一个组件作为参数并返回一个新组件的函数</strong>。这里需要注意<strong>高阶组件是一个函数</strong>，并不是组件，这一点一定要注意。<br>同时这里强调一点高阶组件本身并不是 <code>React</code> API。它只是一种模式，这种模式是由 <code>React</code> 自身的组合性质必然产生的。<br>更加通俗的讲，高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。</p>
<span id="more"></span>
<h2 id="一个简单的高阶组件"><a href="#一个简单的高阶组件" class="headerlink" title="一个简单的高阶组件"></a>一个简单的高阶组件</h2><p>下面我们来实现一个简单的高阶组件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;默认标题&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在其他组件中，我们引用这个高阶组件来强化它<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是一个普通组件</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(Demo);</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看一下<code>React DOM Tree</code>，调用了高阶组件之后，发生了什么：<br><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p1.png" alt="图片"></p>
<p>可以看到，<code>Demo</code> 被 <code>HOC</code> 包裹(wrapped)了之后添加了一个标题默认标题。但是同样会发现，如果调用了多个 <code>HOC</code> 之后，我们会看到很多的<code>HOC</code>，所以应<br>该做一些优化，也就是在高阶组件包裹(wrapped)以后，应该保留原有的名称。</p>
<p>我们改写一下上述的高阶组件代码，增加一个 <code>getDisplayName</code> 函数，之后为<code>Demo</code> 添加一个静态属性 <code>displayName</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getDisplayName = <span class="function"><span class="params">component</span> =&gt;</span> component.displayName || component.name || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;默认标题&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>再次观察<code>React DOM Tree</code></p>
<p><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p2.png" alt="图片"></p>
<p>可以看到，该组件原本的名称已经显示在<code>React DOM Tree</code>上了。<br>这个HOC 的功能是为原有的组件添加一个标题，也就是说所有需要添加标题的组件都可以通过调用此 HOC 进行包裹(wrapped) 后实现此功能。</p>
<h2 id="为高阶组件传参"><a href="#为高阶组件传参" class="headerlink" title="为高阶组件传参"></a>为高阶组件传参</h2><p>现在，我们的 <code>HOC</code> 已经可以为其他任意组件提供标题了，但是我们还希望可以修改标题中的字段。由于我们的高阶组件是一个函数，所以可以为其添加一个参数<code>title</code>。下面我们对<code>HOC</code>进行改写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (WrappedComponent, title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>之后我们进行调用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(Demo,<span class="string">&#x27;高阶组件添加标题&#x27;</span>);</span><br></pre></td></tr></table></figure><br>此时观察<code>React DOM Tree</code>。</p>
<p><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p3.png" alt="图片"></p>
<p>可以看到，标题已经正确的进行了设置。</p>
<p>当然我们也可以对其进行柯里化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(<span class="string">&#x27;高阶组件添加标题&#x27;</span>)(Demo);</span><br></pre></td></tr></table></figure>
<h2 id="常见的HOC-实现方式"><a href="#常见的HOC-实现方式" class="headerlink" title="常见的HOC 实现方式"></a>常见的HOC 实现方式</h2><h3 id="基于属性代理（Props-Proxy）的方式"><a href="#基于属性代理（Props-Proxy）的方式" class="headerlink" title="基于属性代理（Props Proxy）的方式"></a>基于属性代理（Props Proxy）的方式</h3><p>属性代理是最常见的高阶组件的使用方式，上面所说的高阶组件就是这种方式。<br>它通过做一些操作，将被包裹组件的<code>props</code>和新生成的<code>props</code>一起传递给此组件，这称之为属性代理。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">GenerateId</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`PropsBorkerHOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        id: <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">2</span>).toUpperCase()</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> createElement(WrappedComponent, &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        ...newProps</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用<code>GenerateId</code>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PropsBorkerDemo = GenerateId(Demo);</span><br></pre></td></tr></table></figure><br>之后我们观察<code>React Dom Tree</code>：<br><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p4.png" alt="图片"><br>可以看到我们通过 <code>GenerateId</code> 顺利的为 <code>Demo</code> 添加了 <code>id</code>。</p>
<h3 id="基于反向继承（Inheritance-Inversion）的方式"><a href="#基于反向继承（Inheritance-Inversion）的方式" class="headerlink" title="基于反向继承（Inheritance Inversion）的方式"></a>基于反向继承（Inheritance Inversion）的方式</h3><p>首先来看一个简单的反向继承的例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`InheritanceHOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以方便地得到state，做一些更深入的修改。</span></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        innerText: <span class="string">&#x27;我被Inheritance修改了值&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如你所见返回的高阶组件类（<code>Enhancer</code>）继承了 <code>WrappedComponent</code>。而之所以被称为反向继承是因为 <code>WrappedComponent</code> 被动地被 <code>Enhancer</code><br>继承，而不是 <code>WrappedComponent</code> 去继承 <code>Enhancer</code>。通过这种方式他们之间的关系倒转了。</p>
<p>反向继承允许高阶组件通过 <code>this</code> 关键词获取 <code>WrappedComponent</code>，意味着它可以获取到 <code>state</code>，<code>props</code>，组件生命周期（Component Lifecycle）钩子，以及渲染方法（render）。<a href="http://www.jianshu.com/p/0aae7d4d9bc1">深入了解</a>可以阅读<strong>@Wenliang</strong>文章中<code>Inheritance Inversion（II）</code>这一节的内容。</p>
<h2 id="使用高阶组件遇到的问题"><a href="#使用高阶组件遇到的问题" class="headerlink" title="使用高阶组件遇到的问题"></a>使用高阶组件遇到的问题</h2><h3 id="静态方法丢失"><a href="#静态方法丢失" class="headerlink" title="静态方法丢失"></a>静态方法丢失</h3><p>当使用高阶组件包装组件，原始组件被容器组件包裹，也就意味着新组件会丢失原始组件的所有静态方法。<br>下面为 Demo 添加一个静态方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Demo.getDisplayName = <span class="function">() =&gt;</span> <span class="string">&#x27;Demo&#x27;</span>;</span><br></pre></td></tr></table></figure><br>之后调用 <code>HOC</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = HOC(Demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用后的组件是没有 `getDisplayName` 方法的</span></span><br><span class="line"><span class="keyword">typeof</span> WithHeaderDemo.getDisplayName === <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>解决这个问题最简单(Yǘ Chǚn)的方法就是，将原始组件的所有静态方法全部拷贝给新组件：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;fieldset&gt;</span><br><span class="line">          &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;/fieldset&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> HOC.getDisplayName = WrappedComponent.getDisplayName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HOC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样做，就需要你清楚的知道都有哪些静态方法需要拷贝的。或者你也可是使用<a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来帮你自动处理，它会自动拷贝所有非React的静态方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;fieldset&gt;</span><br><span class="line">          &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;/fieldset&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝静态方法</span></span><br><span class="line">  hoistNonReactStatic(HOC, WrappedComponent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HOC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="Refs属性不能传递"><a href="#Refs属性不能传递" class="headerlink" title="Refs属性不能传递"></a>Refs属性不能传递</h3><p>一般来说，高阶组件可以传递所有的props属性给包裹的组件，但是不能传递 <code>refs</code> 引用。因为并不是像 <code>key</code> 一样，<code>refs</code> 是一个伪属性，<code>React</code> 对它进行了特殊处理。<br>如果你向一个由高级组件创建的组件的元素添加 <code>ref</code> 应用，那么 <code>ref</code> 指向的是最外层容器组件实例的，而不是包裹组件。<br>但有的时候，我们不可避免要使用 <code>refs</code>，官方给出的解决方案是：</p>
<blockquote>
<p>传递一个ref回调函数属性，也就是给ref应用一个不同的名字</p>
</blockquote>
<p>同时还强调道：<strong>React在任何时候都不建议使用 ref应用</strong><br>改写 <code>Demo</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    getRef: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDisplayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Demo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      innerText: <span class="string">&#x27;我是一个普通组件&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getRef, ...props &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;getRef&#125; &#123;...props&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.innerText&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后我们进行调用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;WithHeaderDemo</span><br><span class="line">  getRef=&#123;<span class="function">(<span class="params">ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 该回调函数被作为常规的props属性传递</span></span><br><span class="line">    <span class="built_in">this</span>.headerDemo = ref;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><br>虽然这并不是最完美的解决方案，但是<code>React</code>官方说他们正在探索解决这个问题的方法，能够让我们安心的使用高阶组件而不必关注这个问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章只是简单的介绍了高阶组件的两种最常见的使用方式：<code>属性代理</code>和<code>反向继承</code>。以及高阶组件的常见问题。希望通过本文的阅读使你对高阶组件有一个基本的认识。<br>写本文所产生的代码在<a href="https://github.com/hiyangguo/study-hoc">study-hoc</a>中。</p>
<blockquote>
<p>本文作者：<a href="https://github.com/hiyangguo">杨过</a><br>本文同步发表于：<a href="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/">HYPERS 前端博客</a></p>
</blockquote>
<p>参考文章:</p>
<blockquote>
<p><a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher-Order Components</a><br><a href="https://mp.weixin.qq.com/s/AdP-3oA9ofv9hQfDc2r7KA">深入浅出React高阶组件</a><br><a href="https://juejin.im/post/59818a485188255694568ff2">带着三个问题一起深入浅出React高阶组件</a><br><a href="http://t.cn/RKWUqko">阮一峰 - 高阶函数</a><br><a href="http://www.jianshu.com/p/0aae7d4d9bc1">深入理解高阶组件</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>函数式编程</tag>
        <tag>HOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux入门</title>
    <url>/redux-study-beigin/</url>
    <content><![CDATA[<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><code>Action</code> 是一个用来描述应用的 <code>state</code> 的普通 <code>JavaScript</code> 对象。（可以理解为处理前的状态）</li>
<li><code>Reducer</code> 是为了把 <code>action</code> 和 <code>state</code>串起来（即通过处理 <code>action</code> 返回一个 <code>state</code>），而开发的一些函数。它只是一个接收 <code>state</code> 和 一个<code>action</code>，并返回新的 state 的函数</li>
</ul>
<span id="more"></span>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><h3 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h3><p><strong>整个应用的 <code>state</code> 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 <code>store</code> 中。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(store.getState())</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  visibilityFilter: &#x27;SHOW_ALL&#x27;,</span></span><br><span class="line"><span class="comment">  todos: [</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      text: &#x27;Consider using Redux&#x27;,</span></span><br><span class="line"><span class="comment">      completed: true,</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      text: &#x27;Keep all state in a single tree&#x27;,</span></span><br><span class="line"><span class="comment">      completed: false</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-State-是只读的"><a href="#2-State-是只读的" class="headerlink" title="2.State 是只读的"></a>2.State 是只读的</h3><p><strong>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;COMPLETE_TODO&#x27;</span>,</span><br><span class="line">  index: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">  filter: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用纯函数来执行修改"><a href="#3-使用纯函数来执行修改" class="headerlink" title="3.使用纯函数来执行修改"></a>3.使用纯函数来执行修改</h3><p><strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = <span class="string">&#x27;SHOW_ALL&#x27;</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;COMPLETE_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            completed: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reducer = combineReducers(&#123; visibilityFilter, todos &#125;)</span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer)</span><br></pre></td></tr></table></figure></p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p><strong>Action</strong> 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。</p>
<h3 id="Action-创建函数"><a href="#Action-创建函数" class="headerlink" title="Action 创建函数"></a>Action 创建函数</h3><p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。<br>在 Redux 中的 action 创建函数只是简单的返回一个 action:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Reucer"><a href="#Reucer" class="headerlink" title="Reucer"></a>Reucer</h2><p>Action 只是描述了有事情发生了这一事实，而 Reducer 要做的事情是指明应用如何更新 state。</p>
<h3 id="设计-State-结构"><a href="#设计-State-结构" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><p>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。如何才能以最简的形式把应用的 state 用对象描述出来？<br>以 todo 应用为例，需要保存两种不同的数据：</p>
<ul>
<li>当前选中的任务过滤条件</li>
<li>完整的任务列表<br>通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。应该尽量把这些数据与 UI 相关的 state 分开。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  visibilityFilter: <span class="string">&#x27;SHOW_ALL&#x27;</span>,</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">&#x27;Consider using Redux&#x27;</span>,</span><br><span class="line">      completed: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">&#x27;Keep all state in a single tree&#x27;</span>,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Action-处理"><a href="#Action-处理" class="headerlink" title="Action 处理"></a>Action 处理</h3><p>我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure><br>之所以称作 reducer 是因为它将被传递给 Array.prototype.reduce(reducer, ?initialValue) 方法。保持 reducer 纯净非常重要。<br><strong>永远不要</strong> 在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数</li>
<li>执行有副作用的操作，如 API 请求和路由跳转</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code></li>
</ul>
<p><strong>只要传入的参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用、没有 API 请求、没有变量修改，单纯执行计算。</strong><br>现在可以开始编写 reducer，并让它来处理之前定义过的 action。<br>我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 undefined，此时我们可借机设置并返回应用的初始 state。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  visibilityFilter: VisibilityFilters.SHOW_ALL,</span><br><span class="line">  todos: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> state === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> initialState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里暂不处理任何 action，</span></span><br><span class="line">  <span class="comment">// 仅返回传入的 state。</span></span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store 就是把<code>reducers</code>、<code>action</code>、<code>state</code>联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action) 方法更新 state；</li>
<li>通过 subscribe(listener) 注册监听器;</li>
<li>通过 subscribe(listener) 返回的函数注销监听器。<br><strong> Redux 应用只有一个单一的 store。</strong> 当需要拆分数据处理逻辑时，应该使用 reducer 组合 而不是创建多个 store。</li>
</ul>
<p>我们使用 combineReducers() 将多个 reducer 合并成为一个。现在我们将其导入，并传递 createStore()。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br></pre></td></tr></table></figure><br>createStore() 的第二个参数是可选的, 用于设置 state 初始状态。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ol>
<li>调用 store.dispatch(action)。<br>Action 就是一个描述“发生了什么”的普通对象。比如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;LIKE_ARTICLE&#x27;</span>, <span class="attr">articleId</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="attr">response</span>: &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span> &#125; &#125;;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Read the Redux docs.&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。</li>
<li>Redux store 调用传入的 reducer 函数。<br>Store 会把两个参数传入 reducer： 当前的 state 树和 action。例如，在这个 todo 应用中，根 reducer 可能接收这样的数据：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前应用的 state（todos 列表和选中的过滤器）</span></span><br><span class="line"> <span class="keyword">let</span> previousState = &#123;</span><br><span class="line">   visibleTodoFilter: <span class="string">&#x27;SHOW_ALL&#x27;</span>,</span><br><span class="line">   todos: [</span><br><span class="line">     &#123;</span><br><span class="line">       text: <span class="string">&#x27;Read the docs.&#x27;</span>,</span><br><span class="line">       complete: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将要执行的 action（添加一个 todo）</span></span><br><span class="line"> <span class="keyword">let</span> action = &#123;</span><br><span class="line">   type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">   text: <span class="string">&#x27;Understand the flow.&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// render 返回处理后的应用状态</span></span><br><span class="line"> <span class="keyword">let</span> nextState = todoApp(previousState, action);</span><br></pre></td></tr></table></figure>
3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。<br>4.Redux store 保存了根 reducer 返回的完整 state 树。[TOC]</li>
</ol>
<h2 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><code>Action</code> 是一个用来描述应用的 <code>state</code> 的普通 <code>JavaScript</code> 对象。（可以理解为处理前的状态）</li>
<li><code>Reducer</code> 是为了把 <code>action</code> 和 <code>state</code>串起来（即通过处理 <code>action</code> 返回一个 <code>state</code>），而开发的一些函数。它只是一个接收 <code>state</code> 和 一个<code>action</code>，并返回新的 state 的函数</li>
</ul>
<h2 id="三大原则-1"><a href="#三大原则-1" class="headerlink" title="三大原则"></a>三大原则</h2><h3 id="1-单一数据源-1"><a href="#1-单一数据源-1" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h3><p><strong>整个应用的 <code>state</code> 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 <code>store</code> 中。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(store.getState())</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  visibilityFilter: &#x27;SHOW_ALL&#x27;,</span></span><br><span class="line"><span class="comment">  todos: [</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      text: &#x27;Consider using Redux&#x27;,</span></span><br><span class="line"><span class="comment">      completed: true,</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      text: &#x27;Keep all state in a single tree&#x27;,</span></span><br><span class="line"><span class="comment">      completed: false</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-State-是只读的-1"><a href="#2-State-是只读的-1" class="headerlink" title="2.State 是只读的"></a>2.State 是只读的</h3><p><strong>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;COMPLETE_TODO&#x27;</span>,</span><br><span class="line">  index: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">  filter: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用纯函数来执行修改-1"><a href="#3-使用纯函数来执行修改-1" class="headerlink" title="3.使用纯函数来执行修改"></a>3.使用纯函数来执行修改</h3><p><strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = <span class="string">&#x27;SHOW_ALL&#x27;</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;COMPLETE_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            completed: <span class="literal">true</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reducer = combineReducers(&#123; visibilityFilter, todos &#125;)</span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer)</span><br></pre></td></tr></table></figure></p>
<h2 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h2><p><strong>Action</strong> 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。</p>
<h3 id="Action-创建函数-1"><a href="#Action-创建函数-1" class="headerlink" title="Action 创建函数"></a>Action 创建函数</h3><p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。<br>在 Redux 中的 action 创建函数只是简单的返回一个 action:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Reucer-1"><a href="#Reucer-1" class="headerlink" title="Reucer"></a>Reucer</h2><p>Action 只是描述了有事情发生了这一事实，而 Reducer 要做的事情是指明应用如何更新 state。</p>
<h3 id="设计-State-结构-1"><a href="#设计-State-结构-1" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><p>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。如何才能以最简的形式把应用的 state 用对象描述出来？<br>以 todo 应用为例，需要保存两种不同的数据：</p>
<ul>
<li>当前选中的任务过滤条件</li>
<li>完整的任务列表<br>通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。应该尽量把这些数据与 UI 相关的 state 分开。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  visibilityFilter: <span class="string">&#x27;SHOW_ALL&#x27;</span>,</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">&#x27;Consider using Redux&#x27;</span>,</span><br><span class="line">      completed: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">&#x27;Keep all state in a single tree&#x27;</span>,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Action-处理-1"><a href="#Action-处理-1" class="headerlink" title="Action 处理"></a>Action 处理</h3><p>我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure><br>之所以称作 reducer 是因为它将被传递给 Array.prototype.reduce(reducer, ?initialValue) 方法。保持 reducer 纯净非常重要。<br><strong>永远不要</strong> 在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数</li>
<li>执行有副作用的操作，如 API 请求和路由跳转</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code></li>
</ul>
<p><strong>只要传入的参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用、没有 API 请求、没有变量修改，单纯执行计算。</strong><br>现在可以开始编写 reducer，并让它来处理之前定义过的 action。<br>我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 undefined，此时我们可借机设置并返回应用的初始 state。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  visibilityFilter: VisibilityFilters.SHOW_ALL,</span><br><span class="line">  todos: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> state === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> initialState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里暂不处理任何 action，</span></span><br><span class="line">  <span class="comment">// 仅返回传入的 state。</span></span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h2><p>Store 就是把<code>reducers</code>、<code>action</code>、<code>state</code>联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action) 方法更新 state；</li>
<li>通过 subscribe(listener) 注册监听器;</li>
<li>通过 subscribe(listener) 返回的函数注销监听器。<br><strong> Redux 应用只有一个单一的 store。</strong> 当需要拆分数据处理逻辑时，应该使用 reducer 组合 而不是创建多个 store。</li>
</ul>
<p>我们使用 combineReducers() 将多个 reducer 合并成为一个。现在我们将其导入，并传递 createStore()。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br></pre></td></tr></table></figure><br>createStore() 的第二个参数是可选的, 用于设置 state 初始状态。</p>
<h2 id="数据流-1"><a href="#数据流-1" class="headerlink" title="数据流"></a>数据流</h2><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ol>
<li>调用 store.dispatch(action)。<br>Action 就是一个描述“发生了什么”的普通对象。比如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;LIKE_ARTICLE&#x27;</span>, <span class="attr">articleId</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="attr">response</span>: &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span> &#125; &#125;;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Read the Redux docs.&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。</li>
<li>Redux store 调用传入的 reducer 函数。<br>Store 会把两个参数传入 reducer： 当前的 state 树和 action。例如，在这个 todo 应用中，根 reducer 可能接收这样的数据：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前应用的 state（todos 列表和选中的过滤器）</span></span><br><span class="line"> <span class="keyword">let</span> previousState = &#123;</span><br><span class="line">   visibleTodoFilter: <span class="string">&#x27;SHOW_ALL&#x27;</span>,</span><br><span class="line">   todos: [</span><br><span class="line">     &#123;</span><br><span class="line">       text: <span class="string">&#x27;Read the docs.&#x27;</span>,</span><br><span class="line">       complete: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将要执行的 action（添加一个 todo）</span></span><br><span class="line"> <span class="keyword">let</span> action = &#123;</span><br><span class="line">   type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">   text: <span class="string">&#x27;Understand the flow.&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// render 返回处理后的应用状态</span></span><br><span class="line"> <span class="keyword">let</span> nextState = todoApp(previousState, action);</span><br></pre></td></tr></table></figure>
3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。<br>4.Redux store 保存了根 reducer 返回的完整 state 树。</li>
</ol>
]]></content>
      <categories>
        <category>react学习</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 的协变、逆变、双向协变、不变</title>
    <url>/typescript-variant/</url>
    <content><![CDATA[<p><code>TypeScript</code> 给 <code>JavaScript</code> 添加了一套静态类型系统，是为了保证类型安全的，也就是保证变量只能赋同类型的值，对象只能访问它有的属性、方法。<br>但是这种类型安全的限制也不能太死板，有的时候需要一些变通，比如子类型是可以赋值给父类型的变量的，可以完全当成父类型来使用，也就是“<strong>型变（variant）</strong>”（<strong>类型改变</strong>）。<br>这种“型变”分为两种，一种是子类型可以赋值给父类型，叫做<strong>协变（covariant）</strong>，一种是父类型可以赋值给子类型，叫做<strong>逆变（contravariant）</strong>。</p>
<span id="more"></span>
<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><p>子类型可以赋值给父类型的情况就叫做<strong>协变（covariant）</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  subjects: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xaioming&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> zhangsan: Student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  subjects: [<span class="string">&#x27;HTML&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person = zhangsan; <span class="comment">// 这里发生了协变</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&amp;ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3AQL7IEGiSyIoBlMAFcAJhHD4iJMpRp0GIFtOIZhAIwBWEBGAzz6TANoBddlwA2EMMgAOmHDXRRsuALxSSpCtWQByAA84YCxyJj8AGnZWKxsALwALOCUMZJohMQkbD0IvWV8-ROTGVJBIlVoNbV19ZCM-AAkAFQBZABlI-wApOAA3OAEEBlswPzM2VgJ7FxxkDyKU5OZkAHoV5EBN+MAZxMBF5UB8V0AwuUB5ZUAN5SA">试一下</a></p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>函数的参数有<strong>逆变（contravariant）</strong>的性质，即拥有父类型参数的函数可以赋值给子类型的函数。而返回值是<strong>协变</strong>的，也就是子类型可以赋值给父类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  subjects: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printSubjects = <span class="function">(<span class="params">student: Student</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(student.subjects);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printName = <span class="function">(<span class="params">person: Person</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printSubjects = printName; <span class="comment">// 这里由于参数的逆变性质 可以进行赋值</span></span><br><span class="line">printName = printSubjects; <span class="comment">// Type &#x27;(student: Student) =&gt; void&#x27; is not assignable to type &#x27;(person: Person) =&gt; void&#x27;.</span></span><br><span class="line"><span class="comment">// Types of parameters &#x27;student&#x27; and &#x27;person&#x27; are incompatible.</span></span><br><span class="line"><span class="comment">// Property &#x27;subjects&#x27; is missing in type &#x27;Person&#x27; but required in type &#x27;Student&#x27;.(2322)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xaioming&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> zhangsan: Student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  subjects: [<span class="string">&#x27;HTML&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getStudent = (): <span class="function"><span class="params">Student</span> =&gt;</span> zhangsan;</span><br><span class="line"><span class="keyword">let</span> getPerson = (): <span class="function"><span class="params">Person</span> =&gt;</span> person;</span><br><span class="line"></span><br><span class="line">getPerson = getStudent; <span class="comment">//这里由于函数返回值是协变的 可以进行赋值</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.typescriptlang.org/play?ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3AQL7IEGiSyIoBlMAFcAJhHD4iJMpRp0GIFtOIZhAIwBWEBGAzz6TANoBddlwA2EMMgAOisAI3bd+5AAo6YiWBpDv4ACUyAC8AHzIAG5YwKKsBPY8Tlo6eqEeXuJBoRGEJMgIONhWAHQWWIyeIllgJWoproGsbJbWdg4AchTUHraYODToUNggweFRMXFcieBdlOnufcM4Y7kqBUVYpeWVSyMlshBN5gkOyS5pIe08cxDMyAD0D8iAm-GAM4mAjK6AcXKAQ8qADqaAELdAGAJgA3lQDkBoAKWOQgHvlQCncoBt+MAMhGAaVjADwKpxu3XSM0czlSGHurRsewGaH6uCueRk3RoAHIAB5wYBYchMWkAGnYrCsNgAXgALOBKDBCvzVHzpKnEQ50gVCxgikAc9b1C5uIy0gASABUALIAGQ5yFpACk4JE4AIEAxbGBaWY2PEechGNZ-DUFoEqO6JeM5cKhdy2q6wEMRsQru4vWGcDk7OT4iGYxSXW7xeBWEA">试一下</a></p>
<h3 id="双向协变"><a href="#双向协变" class="headerlink" title="双向协变"></a>双向协变</h3><p>在 <strong>ts2.x</strong> 之前支持有父类型参数的函数可以赋值给子类型的函数<strong>（协变）</strong>，同时有子类型参数的函数可以赋值给父类型的函数<strong>（逆变）</strong>。这种特性成为“<strong>双向协变</strong>”。</p>
<p>但是这明显是<strong>有问题的</strong>，不能保证类型安全，所以之后 ts 加了一个编译选项 <a href="https://www.typescriptlang.org/tsconfig#strictFunctionTypes"><code>strictFunctionTypes</code></a>，设置为 <code>true</code> 就只支持函数参数的逆变，设置为 <code>false</code> 则支持双向协变。</p>
<p><img src="/uploads/typescript-variant/strictFunctionTypes.png" alt="strictFunctionTypes"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">printName = printSubjects; <span class="comment">// 将 strictFunctionTypes 设为 false 后，支持函数参数的双向协变，类型检查不会报错，但不能严格保证类型安全。</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&amp;ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3AQL7IEGiSyIoBlMAFcAJhHD4iJMpRp0GIFtOIZhAIwBWEBGAzz6TANoBddlwA2EMMgAOisAI3bd+5AAo6YiWBpDv4ACUyAC8AHzIAG5YwKKsBPY8Tlo6eqEeXuJBoRGEJMgIONhWAHQWWIyeIllgJWoproGsbJbWdg4AchTUHraYODToUNggweFRMXFcieBdlOnufcM4Y7kqBUVYpeWVSyMlshBN5gkOyS5pIe08cxDMyAD0D8iAm-GAM4mAjK6AcXKAQ8qADqaAELdAGAJgA3lQDkBoAKWOQgHvlQCncoBt+MAMhGAaVjADwKpxu3XSM0czlSGHuT2QgDAdWiGXQAMWEIF0wBwABUAJ59DDIQB90YAuOWQ8AsGBQgDgVQAw-99ADPKgEQVUGCuFowBhckA">试一下</a></p>
<h3 id="不变"><a href="#不变" class="headerlink" title="不变"></a>不变</h3><p>型变都是针对父子类型来说的，非父子类型就不会型变也就是<strong>不变（invariant）</strong>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://juejin.cn/book/7047524421182947366">TypeScript 类型体操通关秘籍</a></li>
</ul>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用express实现反向代理服务器</title>
    <url>/use-express-build-proxy-pass/</url>
    <content><![CDATA[<h1 id="node-express-20行代码实现反向代理服务器"><a href="#node-express-20行代码实现反向代理服务器" class="headerlink" title="node express 20行代码实现反向代理服务器"></a>node express 20行代码实现反向代理服务器</h1><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>开发的时候经常会遇到一个问题，就是后台API和前端页面分开开发，但是开发的时候并不想在本地搭建后端环境，因为特别麻烦!特别麻烦!特别麻烦!比如说要配置运行环境、装数据库还有服务器。乱七八糟，有时候光是弄环境就要弄一天。可是如果不配置又没办法开发。最主要的是请求后端API的时候会遇到跨域问题。最简单的方法当然是后端帮忙配一个<code>CORS</code>。但是如果后端没办法配合的话，可能就比较麻烦了。这时候可以使用反向代理进行开发。</p>
<span id="more"></span>
<h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>首先科普一下代理，代理分为正向代理和反向代理</p>
<ul>
<li><p>正向代理</p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。<br>–摘自百度百科</p>
</blockquote>
</li>
<li><p>反向代理</p>
<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。<br>–摘自百度百科</p>
</blockquote>
</li>
</ul>
<p>两者的主要区别在于代理的对象不一样： 正向代理代理的对象是客户端，反向代理代理的对象是服务端。<br>而我们遇到的问题就是需要使用反向代理解决。</p>
<h2 id="开始撸代码"><a href="#开始撸代码" class="headerlink" title="开始撸代码"></a>开始撸代码</h2><p>说到反向代理第一反应肯定是<code>Nginx</code>。确实<code>Nginx</code>做反代确实很好，但是说实话，没必要特意为了做个API的代理装个<code>Nginx</code>。而且还要去学习<code>Nginx</code>的配置。<br>另外，可能会想到<code>webpack</code>，当然如果你使用了<code>webpack</code>，直接就可以使用<code>webpack-dev-server</code>了。<br>但如果你手头上接手了一个老项目就比较尴尬了。下面进入正题使用<code>express</code>做开发代理服务器。</p>
<p>首先安装<code>express</code>和<code>superagent</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev express superagent</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>express是基于 Node.js 平台，快速、开放、极简的 web 开发框架。<br>superagent是 Nodejs 里一个非常方便的客户端请求代理模块.</p>
</blockquote>
<p>之后新建一个<code>server.js</code>文件。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//这里从环境变量读取配置，方便命令行启动</span></span><br><span class="line"><span class="keyword">const</span> &#123; HOST = <span class="string">&#x27;http://10.0.1.10:8080&#x27;</span>, PORT = <span class="string">&#x27;3300&#x27;</span> &#125; = process.env;</span><br><span class="line"><span class="comment">//转换body用于读取</span></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;connect&#x27;</span>).bodyParser());</span><br><span class="line"><span class="comment">//设置端口</span></span><br><span class="line">app.set(<span class="string">&#x27;port&#x27;</span>, PORT);</span><br><span class="line"><span class="comment">//反向代理（这里把需要进行反代的路径配置到这里即可）</span></span><br><span class="line"><span class="comment">//如需要将/api/test 代理到 $&#123;HOST&#125;/api/test</span></span><br><span class="line">app.use(<span class="string">&#x27;/api/test*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> sreq = request[method](HOST + req.originalUrl);</span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">&#x27;post&#x27;</span> || method === <span class="string">&#x27;put&#x27;</span>) &#123;</span><br><span class="line">        sreq.set(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">            .send(req.body)</span><br><span class="line">    &#125;</span><br><span class="line">    sreq.pipe(res);</span><br><span class="line">    sreq.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//静态页面</span></span><br><span class="line"><span class="comment">//这里一般设置你的静态资源路径</span></span><br><span class="line">app.use(<span class="string">&#x27;/route&#x27;</span>, express.static(<span class="string">&#x27;src&#x27;</span>));</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.listen(app.get(<span class="string">&#x27;port&#x27;</span>), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server running @<span class="subst">$&#123;app.get(<span class="string">&#x27;port&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node dev-server.js</span><br></pre></td></tr></table></figure><br>这时会使用打开<code>http://localhost:3300/route</code>即可</p>
<p>动态设置端口和反向代理地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HOST&#x3D;http:&#x2F;&#x2F;10.0.1.10:8081 PORT&#x3D;3301 node dev-server.js</span><br></pre></td></tr></table></figure><br>此时则需要在<code>http://localhost:3301/route</code>进行访问。<br>至此，一个简单可用的开发环境就搞定了。</p>
<p>理论介绍参考:<br><a href="https://www.zhihu.com/question/24723688">反向代理为何叫反向代理？</a><br><a href="https://segmentfault.com/a/1190000000762548">正向代理与反向代理的浅解</a></p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>开发环境</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 换肤功能多主题/配色样式打包解决方案</title>
    <url>/webpack-mutiple-theme-solution-md/</url>
    <content><![CDATA[<p><img src="/uploads/webpack-mutiple-theme-solution/pallete.jpg" alt="色阶"><br>本文主要详细介绍了，如何使用 <a href="https://webpack.js.org/">webpack</a>，打包多套不同主题的解决方案以及实践中所遇到的问题及解决方案。</p>
<span id="more"></span>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>首先，简单的介绍一下什么是多主题，所谓多套主题/配色，就是我们很常见的换肤功能。换肤简单来说就是更换 <code>css</code>。这是一个老生常谈的问题，具体实践请参考<a href="https://hiyangguo.github.io/2017/03/21/less-multiple-color-theme-realize/">less 换肤功能实践</a>。本文不在赘述。<br>一般实现多主题的样式文件，我们都会借用 <a href="https://www.gulpjs.com.cn/">gulp</a>、<a href="https://gruntjs.com/">grunt</a>这种构建工具进行构建。但是，这样做有一个巨大的问题，就是非常不方便。我们既然已经使用了 <code>webpack</code> 进行打包，又为什么还要使用其他的构建工具呢？<br>另外，还有一个巨大的弊端就是使用其他构建工具构建的 css ，是没办法支持提供的 <a href="https://www.npmjs.com/package/css-loader#scope">scope</a>功能的。这非常致命。所以到底该如何使用 webpack 进行构建呢？</p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>新建一些 <code>&lt;theme&gt;.less</code>文件，，使用 <code>webpack</code> 读取 <code>themes</code>目录中的样式文件，编译后输出 <code>&lt;theme&gt;.css</code>。并且首次加载时只引用默认主题文件，其他的可以到切换的时候再引入。<br>所以只需要解决解决编译多套 css 输出的问题和不让 css 注入 html 的问题就好了。</p>
<h2 id="解决编译多套-css-输出的问题"><a href="#解决编译多套-css-输出的问题" class="headerlink" title="解决编译多套 css 输出的问题"></a>解决编译多套 css 输出的问题</h2><ul>
<li>建立一个<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/tree/v0.0.1">初始化的项目</a>，这个项目以<code>react</code>项目为例，预编译语言使用的是<code>less</code>。你可以随着自己的喜好进行任意选择。<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/blob/v0.0.1/webpack.config.js">初始配置</a>。然后再<code>less</code>文件夹下，新建一个<code>themes</code>目录，和多个 <code>&lt;theme&gt;.less</code>。<br><img src="/uploads/webpack-mutiple-theme-solution/themes.png" alt="目录结构"><br>建好之后，把所有的 文件引入 <code>index.js</code>中，<code>webpack</code>就会帮你把他们编译输出到一起了。一般情况下，<a href="https://www.npmjs.com/package/extract-text-webpack-plugin">extract-text-webpack-plugin</a> 可以帮我们把样式文件抽出来，但是会帮我们把他们都放在同一个文件中。<br>修改<code>index.js</code>。</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import &#x27;./less/index.less&#x27;;</span><br><span class="line"><span class="addition">+ import &#x27;./less/themes/green.less&#x27;;</span></span><br><span class="line"><span class="addition">+ import &#x27;./less/themes/red.less&#x27;;</span></span><br><span class="line"><span class="addition">+ import &#x27;./less/themes/yellow.less&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>然后编译一下，你发现所有的样式都混在一起了。<br><img src="/uploads/webpack-mutiple-theme-solution/mix-css.png" alt="混在一起的样式"><br>参照文档，我们需要多次声明 <code>ExtractTextPlugin</code>，以达到把不同的主题输出到不同文件的目的。这里我使用的是, <code>loader</code> 的 <code>include</code> 和 <code>exclude</code>参数。在默认样式中将其他样式排除，然后每一个主题的样式,分别打包自己的样式。<br>最终代码的改动如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"><span class="addition">+ const fs = require(&#x27;fs&#x27;);</span></span><br><span class="line">const webpack = require(&#x27;webpack&#x27;);</span><br><span class="line">const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);</span><br><span class="line">const HtmlwebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">const &#123; STYLE_DEBUG &#125; = process.env;</span><br><span class="line"><span class="addition">+ // 主题路径</span></span><br><span class="line"><span class="addition">+ const THEME_PATH = &#x27;./src/less/themes&#x27;;</span></span><br><span class="line"></span><br><span class="line">const extractLess = new ExtractTextPlugin(&#x27;style.[hash].css&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="addition">+ const styleLoaders = [&#123; loader: &#x27;css-loader&#x27; &#125;, &#123; loader: &#x27;less-loader&#x27; &#125;];</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const resolveToThemeStaticPath = fileName =&gt; path.resolve(THEME_PATH, fileName);</span></span><br><span class="line"><span class="addition">+ const themeFileNameSet = fs.readdirSync(path.resolve(THEME_PATH));</span></span><br><span class="line"><span class="addition">+ const themePaths = themeFileNameSet.map(resolveToThemeStaticPath);</span></span><br><span class="line"><span class="addition">+ const getThemeName = fileName =&gt; `theme-$&#123;path.basename(fileName, path.extname(fileName))&#125;`;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ // 全部 ExtractLessS 的集合</span></span><br><span class="line"><span class="addition">+ const themesExtractLessSet = themeFileNameSet.map(fileName =&gt; new ExtractTextPlugin(`$&#123;getThemeName(fileName)&#125;.css`))</span></span><br><span class="line"><span class="addition">+ // 主题 Loader 的集合</span></span><br><span class="line"><span class="addition">+ const themeLoaderSet = themeFileNameSet.map((fileName, index) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+   return &#123;</span></span><br><span class="line"><span class="addition">+     test: /\.(less|css)$/,</span></span><br><span class="line"><span class="addition">+     include: resolveToThemeStaticPath(fileName),</span></span><br><span class="line"><span class="addition">+     loader: themesExtractLessSet[index].extract(&#123;</span></span><br><span class="line"><span class="addition">+       use: styleLoaders</span></span><br><span class="line"><span class="addition">+     &#125;)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+ &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//..... 这里省略了</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#x27;transform-loader?brfs&#x27;, // Use browserify transforms as webpack-loader.</span><br><span class="line">          &#x27;babel-loader?babelrc&#x27;</span><br><span class="line">        ],</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(less|css)$/,</span><br><span class="line">        exclude: themePaths,</span><br><span class="line">        loader: extractLess.extract(&#123;</span><br><span class="line"><span class="deletion">-          use: [</span></span><br><span class="line"><span class="deletion">-            &#123;</span></span><br><span class="line"><span class="deletion">-              loader: &#x27;css-loader&#x27;,</span></span><br><span class="line"><span class="deletion">-            &#125;, &#123;</span></span><br><span class="line"><span class="deletion">-              loader: &#x27;less-loader&#x27;</span></span><br><span class="line"><span class="deletion">-            &#125;</span></span><br><span class="line"><span class="deletion">-          ],</span></span><br><span class="line"><span class="addition">+          use: styleLoaders,</span></span><br><span class="line">          // use style-loader in development</span><br><span class="line">          fallback: &#x27;style-loader?&#123;attrs:&#123;prop: &quot;value&quot;&#125;&#125;&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#x27;html-loader&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="addition">+      ...themeLoaderSet</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    extractLess,</span><br><span class="line"><span class="addition">+    ...themesExtractLessSet,</span></span><br><span class="line">    new webpack.NamedModulesPlugin(),</span><br><span class="line">    new HtmlwebpackPlugin(&#123;</span><br><span class="line">      title: &#x27;webpack 多主题打包演示&#x27;,</span><br><span class="line">      template: &#x27;src/index.html&#x27;,</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  devtool: STYLE_DEBUG <span class="comment">=== &#x27;SOURCE&#x27; &amp;&amp; &#x27;source-map&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做出以上改动之后，就可以正常的输出样式文件了。<br><img src="/uploads/webpack-mutiple-theme-solution/first-build.png" alt="第一次构建"></p>
<p><a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/commit/1509f94524626331731893253aec2d2ce6936911">详细的代码改动</a>在这里，并且有详细的注释。</p>
<h2 id="不让-css-注入-html"><a href="#不让-css-注入-html" class="headerlink" title="不让 css 注入 html"></a>不让 css 注入 html</h2><p>这样做之后，虽然 <code>webpack</code> 可以正常的编译样式文件了，但是有一个致命的问题。让我们看看现在的<code>&lt;head/&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack 多主题打包演示页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/resources/loading.css&quot;</span> /&gt;</span></span><br><span class="line">  &lt;link</span><br><span class="line">    rel=&quot;stylesheet&quot;</span><br><span class="line">    href=&quot;https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">    type=&quot;text/javascript&quot;</span><br><span class="line">    src=&quot;//cdn.staticfile.org/babel-standalone/6.24.0/babel.min.js&quot;</span><br><span class="line">  &gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=default|gated,Array.prototype.includes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/style.984c33e9f2d50d6db720.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/theme-green.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/theme-red.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/theme-yellow.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们发现不仅注入了<code>style.css</code>同时注入了所有的<code>theme.css</code>。这显然不是我们想要的。所以有什么办法把多余的主题去掉呢？</p>
<h3 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h3><p>用<code>node</code>写一个脚本，读取<code>html</code>，然后移除。这样又与我们最开始的初衷相违背，还是借助了其他的外力。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><a href="https://www.npmjs.com/package/extract-text-webpack-plugin">extract-text-webpack-plugin</a> 提供了一个 <code>excludeChunks</code>方法，可以用来排除 <code>entry</code> 。所以我们可以把所有的样式文件放入，<code>themes.js</code> 中然后 在 entry 中添加 <code>themes</code>。再使用<code>excludeChunks</code>排除它就好了。</p>
<ul>
<li>删除 <code>index.js</code> 中的样式引用。</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// style</span><br><span class="line">import &#x27;./less/index.less&#x27;;</span><br><span class="line"><span class="deletion">- import &#x27;./less/themes/green.less&#x27;;</span></span><br><span class="line"><span class="deletion">- import &#x27;./less/themes/red.less&#x27;;</span></span><br><span class="line"><span class="deletion">- import &#x27;./less/themes/yellow.less&#x27;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建<code>themes.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./less/themes/green.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./less/themes/red.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./less/themes/yellow.less&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 <code>webpack.config.js</code></li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  entry: &#123;</span><br><span class="line">    app: &#x27;./src/index.js&#x27;,</span><br><span class="line"><span class="addition">+   themes: &#x27;./src/themes.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">//</span><br><span class="line">//... 省略没用的代码</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">new HtmlwebpackPlugin(&#123;</span><br><span class="line">  title: &#x27;webpack 多主题打包演示&#x27;,</span><br><span class="line">  template: &#x27;src/index.html&#x27;,</span><br><span class="line">  inject: true,</span><br><span class="line"><span class="addition">+ excludeChunks: [&#x27;themes&#x27;]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/webpack-mutiple-theme-solution/first-build.png" alt="使用 excludeChunks方式构建"><br>但是这时候，发现多了一个 <code>themes.bundle.js</code>文件。所以需要删除掉。修改 <code>build</code>脚本。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &quot;rm -rf dist &amp;&amp; NODE_ENV=production webpack --mode production --progress &amp;&amp; cp -R public/* ./dist/ &quot;</span><br><span class="line">&quot;build&quot;: &quot;rm -rf dist &amp;&amp; NODE_ENV=production webpack --mode production --progress &amp;&amp; cp -R public/* ./dist/ &amp;&amp; &amp;&amp; rm -rf dist/themes.bundle.js&quot;</span><br></pre></td></tr></table></figure>
<p>这样就大功告成了。<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/commit/90c1f24af526cd6d48bf6b095500e4ffa5c7f0e6">更改记录</a>，<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo">完整代码</a></p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>但是，加了句 <code>rm -rf</code>，还是感觉有点不爽。所以在仔细的阅读了<a href="https://www.npmjs.com/package/extract-text-webpack-plugin">extract-text-webpack-plugin</a>文档后，我发现他提供了一个钩子函数<code>html-webpack-plugin-after-html-processing</code>。可以处理<code>html</code>。<a href="html-webpack-handle-css-inject-plugin-js">HtmlWebpackHandleCssInjectPlugin.js</a>（<strong>支持<code>webpack4</code>和其他 <code>webpack</code> 版本</strong>）。<br>然后这样使用：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ const HtmlWebpackHandleCssInjectPlugin = require(&#x27;./HtmlWebpackHandleCssInjectPlugin&#x27;);</span></span><br><span class="line">//... 省略没用的代码</span><br><span class="line">  plugins: [</span><br><span class="line">    extractLess,</span><br><span class="line">    // 将所有的 themesExtractLess 加入 plugin</span><br><span class="line">    ...themesExtractLessSet,</span><br><span class="line">    new webpack.NamedModulesPlugin(),</span><br><span class="line">    new HtmlwebpackPlugin(&#123;</span><br><span class="line">      title: &#x27;webpack 多主题打包演示&#x27;,</span><br><span class="line">      template: &#x27;src/index.html&#x27;,</span><br><span class="line">      inject: true</span><br><span class="line"><span class="addition">+    &#125;),</span></span><br><span class="line"><span class="addition">+    new HtmlWebpackHandleCssInjectPlugin(&#123;</span></span><br><span class="line"><span class="addition">+      filter: (filePath) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+        return filePath.includes(&#x27;style&#x27;);</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;)</span></span><br><span class="line"><span class="addition">+  ],</span></span><br></pre></td></tr></table></figure>
<p><code>filter</code> 函数<code>Array.filer</code>用法一直。参数<code>filePath</code>参数给出的就是<code>link</code>标签中<code>[href]</code>的值。<br>这个方法，既不需要任何工具，也不需要删除什么。非常完美。<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/commit/2688cead3298b65a4e5871ead1d261b008b545a8">更改记录</a>,<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo/tree/plugin">完整代码</a><br><img src="/uploads/webpack-mutiple-theme-solution/fina-build.png" alt="使用 hook方式构建"></p>
<p>这两种方法我个人比较倾向于方法三。由于 plugin 的代码比较简单，就不做 publish 了。需要的欢迎自取。<br>本文章所涉及的<a href="https://github.com/hiyangguo/webpack-mutiple-theme-bundle-css-demo">源码</a>。<a href="#方法二">方法二</a>和<a href="#方法三">方法三</a>在不同的分支，<a href="https://hiyangguo.github.io/webpack-mutiple-theme-bundle-css-demo/">点击查看最终效果</a><br><img src="/uploads/webpack-mutiple-theme-solution/final-screenshoots.gif" alt="最终效果截屏"></p>
<p>最后感谢<a href="https://github.com/xiyuyizhi">@xiyuyizhi</a>提供的<a href="https://github.com/xiyuyizhi/notes/blob/master/js/theme.md">宝贵思路</a>。<br>本文纯属原创，如有错误欢迎指正。</p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
        <tag>webpack</tag>
        <tag>换肤</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】javascript中的undefined可以被重写</title>
    <url>/%E3%80%90%E8%AF%91%E3%80%91javascript%E4%B8%AD%E7%9A%84undefined%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>众所周知,当声明一个变量，并且没有给赋值的情况下，它的初始值是 <code>undefined</code>。<br>但是在javascript中，怎么检查一个值是否为 <code>undefined</code> 呢？</p>
<h1 id="简单的回答"><a href="#简单的回答" class="headerlink" title="简单的回答"></a>简单的回答</h1><p>在现代浏览器中，你可以安全的直接比较将变量是与 <code>undefined</code> 进行比较<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一些人反对直接使用 <code>undefined</code> 变量进行比较，因为在旧的浏览器中它允许被重新赋值，像下面这样:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><br>在被重新赋值后,直接使用 <code>undefined</code> 将不能正确的检测一个变量是否被赋值。<br>然而，这一行为在2009年的<a href="https://es5.github.io/#x15.1.1.3">ECMAScript 5</a>被修复了。</p>
<span id="more"></span>
<blockquote>
<p>15.1.1.3 undefined<br>The value of undefined is undefined (see 8.1). This property has the attributes { <strong>[[Writable]]: false</strong>, [[Enumerable]]: false, [[Configurable]]: false }.<br><code>undefined</code> 的值是 <code>undefined</code>。这个属性有<strong>不可写</strong>，<strong>不可枚举</strong>，<strong>不可配置</strong>的特性。</p>
</blockquote>
<p>在现代浏览器中，<code>undefined</code>的值将不能被重写</p>
<h1 id="我们需要支持ie8或者更古老的浏览器怎么办"><a href="#我们需要支持ie8或者更古老的浏览器怎么办" class="headerlink" title="我们需要支持ie8或者更古老的浏览器怎么办"></a>我们需要支持ie8或者更古老的浏览器怎么办</h1><p>通常<code>undefined</code>指令是安全的。在应用中并没有什么理由需要修改<code>undefined</code>的值。<br><a href="http://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/3390635#3390635">Thomas的回答</a>使用具有说服力的推理，论证了这一点。</p>
<blockquote>
<p>我没有听从人们告诉我，我不应该使用<code>setTimeout</code>，因为有人可以（这样用）:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Got you now!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>下面一行，它可以重新定义参数，替换原始值，使 <code>raw === undefined</code> 看起来是假的。<br>如果你仍然很在意,有两个方法在即使全局 <code>window.undefined</code> 已经被重写的情况下，依然可以检查一个值是否为 <code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name === <span class="keyword">void</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子中 <code>0</code> 没有任何实际意义,你想要使用 <code>1</code> or <code>function()&#123;&#125;</code>也无所谓。 <code>void(anything)</code>都会计算得到<code>undefiend</code></p>
</blockquote>
<p>另外一种选择，你可以使用<code>typeof</code>操作符安全地检查是否已经被赋值。你可以检查一个值的类型是否为 “<code>undefined</code>“ 代替与全局的 <code>undefined</code> 比较.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意第二个选择与前一个方案稍微有点差异。虽然<code>name</code>没有被声明，<code>typeof</code> 仍然会说他是 <code>undefined</code>。如果你直接使用 <code>name</code> 与 <code>undefined</code>or <code>void(0)</code>你会得到<code>ReferenceError</code>异常的错误.</p>
<h1 id="但是不要直接使用void-0"><a href="#但是不要直接使用void-0" class="headerlink" title="但是不要直接使用void(0)"></a>但是不要直接使用void(0)</h1><p>在代码中避免使用<code>void(0)</code>或者<code>typeof x === &quot;undefined&quot;</code>，这些表达式不是自解释的，应该包装在<code>isUndefined function</code>函数中，像这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获得undefined，保证它没有被重新赋值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>许多的工具库已经部署了这个方法,例如:<code>_.isUndefined</code>，<a href="http://underscorejs.org/#isUndefined">underscore中的isUndefined方法</a></p>
<blockquote>
<p><a href="http://www.codereadability.com/how-to-check-for-undefined-in-javascript/">原文地址</a><br>原文标题：在javascript中怎样检查undefiend</p>
</blockquote>
<p>初次翻译，如有错误，欢迎指正</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常见的开源协议</title>
    <url>/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="几种常见的开源协议"><a href="#几种常见的开源协议" class="headerlink" title="几种常见的开源协议"></a>几种常见的开源协议</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://zh.wikipedia.org/wiki/开源软件">开源软件</a>(Open source software)对我们来说越来越不陌生，开源软件一方面让我们享用到了“免费的午餐”，另一方面有效的利用和学习开源软件，也能促进我们开发软件时的效率、提升软件质量。但是在使用和借鉴开源软件的时候，我们不得不关心一下它对使用者的诸多限制，比较常见的方式即协议授权(licence)，这些协议中明确说明了使用者应该遵循的原则。</p>
<p>现在开源协议众多，通过<a href="http://opensource.org/licenses/category">Open Source Initiative</a>组织批准的开源协议有50多种，本文介绍其中一些常见的协议。</p>
<span id="more"></span>
<h2 id="常见的协议介绍"><a href="#常见的协议介绍" class="headerlink" title="常见的协议介绍"></a>常见的协议介绍</h2><h3 id="BSD协议"><a href="#BSD协议" class="headerlink" title="BSD协议"></a><a href="http://zh.wikipedia.org/wiki/BSD许可证">BSD协议</a></h3><p>BSD开源协议是一个给予使用者很大自由的协议。开发者可以自由使用和修改源代码，也可以讲修改后的源代码作为开源或者专有软件再发布。但是有一下几个要求：</p>
<ul>
<li>如果再发布的产品中含有源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要再类库/软件的文档和版权申明中包含原有代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<h3 id="Apache-Licence-2-0-Apache-2-0"><a href="#Apache-Licence-2-0-Apache-2-0" class="headerlink" title="Apache Licence 2.0(Apache-2.0)"></a><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache Licence 2.0</a>(Apache-2.0)</h3><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p>
<ul>
<li>需要给代码的用户一份Apache Licence。</li>
<li>如果修改了代码，需要再被修改的文件中说明。</li>
<li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
</ul>
<p>使用这个协议的好处是:</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</p>
<h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a><a href="http://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a></h3><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<p>GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>
<p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p>
<p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p>
<h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a><a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a></h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a><a href="http://opensource.org/licenses/mit-license.php">MIT</a></h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。<br>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<h3 id="MPL-Mozilla-Public-License-1-1"><a href="#MPL-Mozilla-Public-License-1-1" class="headerlink" title="MPL (Mozilla Public License 1.1)"></a><a href="https://zh.wikipedia.org/zh/Mozilla%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81">MPL</a> (Mozilla Public License 1.1)</h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>
<h3 id="EPL-Eclipse-Public-License-1-0"><a href="#EPL-Eclipse-Public-License-1-0" class="headerlink" title="EPL (Eclipse Public License 1.0)"></a><a href="https://zh.wikipedia.org/wiki/Eclipse%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81">EPL</a> (Eclipse Public License 1.0)</h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。<br>使用EPL协议，需要遵守以下规则：</p>
<ol>
<li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原“源码”Owner 的授权；</li>
<li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li>
<li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；<br>4.独立的模块(Separate Module),不需要开源。<h2 id="各协议分析图"><a href="#各协议分析图" class="headerlink" title="各协议分析图"></a>各协议分析图</h2></li>
</ol>
<p>乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。<a href="http://www.ruanyifeng.com/">阮一峰</a>对图进行了汉化，如下图：</p>
<p><img src="http://cms.csdnimg.cn/article/201409/01/54040fdd4d9b1.jpg" alt="各种协议分析图"></p>
<blockquote>
<p>参考:</p>
<ul>
<li><a href="http://yansu.org/2013/04/23/opensource-licenses.html">http://yansu.org/2013/04/23/opensource-licenses.html</a></li>
<li><a href="http://blog.jasonding.top/2015/05/11/Git/%E3%80%90Git%E3%80%91%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%85%B3%E7%B3%BB/#MPL-Mozilla-Public-License-1-1">认识各种开源协议及其关系</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>开源</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用入门教程</title>
    <url>/git-tutorials/</url>
    <content><![CDATA[<h1 id="大纲图"><a href="#大纲图" class="headerlink" title="大纲图"></a>大纲图</h1><p><img src="/uploads/git-tutorials/git-outline.png" alt="git入门教程"></p>
<span id="more"></span>
<p><a href="http://naotu.baidu.com/file/5dcda8cf019f0f79dc6285c98298daf8?token=a65a47efab6ab2be">原图地址</a></p>
<h1 id="起步-关于版本控制"><a href="#起步-关于版本控制" class="headerlink" title="起步 - 关于版本控制"></a>起步 - 关于版本控制</h1><ul>
<li>什么是“版本控制”？<blockquote>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
</blockquote>
</li>
</ul>
<h2 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h2><ul>
<li>使用本地数据库记录文件的历次更新<strong>差异</strong></li>
</ul>
<p><img src="/uploads/git-tutorials/version-control-1.png" alt="git入门教程"></p>
<blockquote>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。<br>这么做唯一的好处就是简单，但是特别容易犯错。<br>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。<br>其中最流行的一种叫做 RCS，它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
</blockquote>
<h2 id="集中化的版本控制系统-Centralized-Version-Control-Systems，简称-CVCS"><a href="#集中化的版本控制系统-Centralized-Version-Control-Systems，简称-CVCS" class="headerlink" title="集中化的版本控制系统 Centralized Version Control Systems，简称 CVCS"></a>集中化的版本控制系统 Centralized Version Control Systems，简称 CVCS</h2><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统</p>
<ul>
<li>优点：方便协作、权限控制、相比于维护本地数据库成本更低</li>
<li>缺点：容错率低（服务器宕机、服务器数据丢失导致不可恢复的问题）<br><img src="/uploads/git-tutorials/version-control-2.png" alt="git入门教程"></li>
</ul>
<h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><ul>
<li>客户端把代码仓库<strong>完整地镜像</strong>下来。每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</li>
<li>这类系统都可以指定和若干不同的远端代码仓库进行交互。<br><img src="/uploads/git-tutorials/version-control-3.png" alt="git入门教程"></li>
</ul>
<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>Git 是目前世界上被最广泛使用的现代软件版本管理系统。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li>
<li>完全分布式</li>
<li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
</ul>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul>
<li>Mac 用户：Xcode Command Line Tools 自带 Git (<code>xcode-select --install</code>)</li>
<li>Linux 用户：<code>sudo apt-get install git</code></li>
<li>Windows 用户：下载 <a href="https://git-scm.com/">Git SCM</a></li>
<li>对于 Windows 用户，安装后如果希望在全局的 cmd 中使用 git，需要把 git.exe 加入 PATH 环境变量中，或在 Git Bash 中使用 Git。</li>
</ul>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul>
<li><a href="https://coding.net/help/doc/git/ssh-key.html">配置SSH公钥</a></li>
</ul>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;your_username&quot;</span><br><span class="line">$ git config --global user.email your_email@domain.com</span><br></pre></td></tr></table></figure>
<h2 id="git-config-常用配置"><a href="#git-config-常用配置" class="headerlink" title="git config 常用配置"></a><code>git config</code> 常用配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器</span><br><span class="line">$ git config --global core.editor emacs</span><br><span class="line"># 设置 commit 的模板</span><br><span class="line">$ git config --global commit.template ~&#x2F;.gitmessage.txt</span><br><span class="line"># 查看最后10次提交 </span><br><span class="line">$ git config --global alias.last &quot;log -10 --pretty&#x3D;format:&#39;%C(yellow)%h%Creset(%Cred%ad%Creset) - %Cgreen%aN%Creset : %s&#39;  --date&#x3D;format:&#39;%Y-%m-%d %H:%M:%S&#39; --graph&quot;</span><br></pre></td></tr></table></figure>
<p>Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。</p>
<ul>
<li><code>.git/config</code> – 特定仓库的设置。</li>
<li><code>~/.gitconfig</code> – 特定用户的设置。这也是 <code>--global</code> 标记的设置项存放的位置。</li>
<li><code>$(prefix)/etc/gitconfig</code> – 系统层面的设置。</li>
</ul>
<p>所有配置项都储存在纯文本文件中，所以 <code>git config</code> 命令其实只是一个提供便捷的命令行接口。</p>
<blockquote>
<p>拓展阅读<br>  <a href="https://stackoverflow.com/questions/2596805/how-do-i-make-git-use-the-editor-of-my-choice-for-commits">How do I make Git use the editor of my choice for commits?</a><br>  <a href="https://git-scm.com/docs/git-log#_pretty_formats">Git log pretty formats</a></p>
</blockquote>
<h1 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h1><p>语法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><br>例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地仓库</span><br><span class="line">$ git clone &#x2F;path&#x2F;to&#x2F;repository</span><br><span class="line"># 通过 SSH</span><br><span class="line">$ git clone git@git.hypers.com:Godfery&#x2F;git-share-salloto.git</span><br><span class="line"># 通过 HTTPS</span><br><span class="line">$ git clone https:&#x2F;path&#x2F;to&#x2F;repository.git</span><br></pre></td></tr></table></figure><br>克隆某个分支<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master git@git.hypers.com:Godfery/git-share-salloto.git</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTPS和-SSH"><a href="#HTTPS和-SSH" class="headerlink" title="HTTPS和 SSH"></a>HTTPS和 SSH</h2><blockquote>
<ul>
<li>HTTPS：拿到url可以随便clone，但是在push的时候需要验证用户名和密码；可以缓存密码</li>
<li>SSH：安全，需要在clone前添加SSH Key。SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</li>
</ul>
</blockquote>
<blockquote>
<p>拓展阅读<br><a href="http://wanderyt.github.io/2016/04/12/Git-Url-HTTPS-SSH-Difference/">Git Url HTTPS SSH 区别</a></p>
</blockquote>
<h1 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">#在指定目录创建一个空的 Git 仓库</span><br><span class="line">git init &lt;directory&gt;</span><br><span class="line">#初始化一个裸的 Git 仓库</span><br><span class="line">git init --bare &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/git-tutorials/git-init-bare.svg" alt="初始化裸仓库"></p>
<p>无论什么时候，都可以通过 <code>git status</code> 来查看你的 git 仓库状态。</p>
<blockquote>
<p><code>-—bare</code> 标记创建了一个没有工作目录的仓库，这样我们在仓库中更改文件并且提交了。中央仓库应该总是创建成裸仓库，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将<code>-—bare</code>看成是用来将仓库标记为储存设施，而不是一个开发环境。也就是说，对于所有的 Git 工作流，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。</p>
</blockquote>
<h1 id="管理-remote"><a href="#管理-remote" class="headerlink" title="管理 remote"></a>管理 <code>remote</code></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前 remote</span></span><br><span class="line">$ git remote -v  </span><br><span class="line"><span class="comment"># 删除 remote</span></span><br><span class="line">$ git remote remove origin</span><br><span class="line"><span class="comment"># 添加 remote</span></span><br><span class="line">$ git remote add origin git@git.hypers.com:Godfery/git-share-salloto.git</span><br></pre></td></tr></table></figure>
<h1 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h1><h2 id="本地工作流"><a href="#本地工作流" class="headerlink" title="本地工作流"></a>本地工作流</h2><p><img src="/uploads/git-tutorials/workflow.png" alt="git入门教程"></p>
<blockquote>
<p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的 <code>工作目录</code>，它持有实际文件；<br>第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；<br>最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/uploads/git-tutorials/workflow2.png" alt="工作原理"></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>仓库（Repository）</td>
<td>一个仓库包括了所有的版本信息、所有的分支和标记信息。在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。</td>
</tr>
<tr>
<td>分支（Branches）</td>
<td>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。</td>
</tr>
<tr>
<td>标签（Tags）</td>
<td>一个标记指的是某个分支某个特定时间点的状态。</td>
</tr>
<tr>
<td>提交（Commit）</td>
<td>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。</td>
</tr>
<tr>
<td>修订（Revision）</td>
<td>用来表示代码的一个版本状态。最新的版本可以通过HEAD来获取。之前的版本可以通过”HEAD~1”来获取，以此类推。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长，16进制标识的字符串。</td>
</tr>
</tbody>
</table>
<h1 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h1><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加某个文件</span></span><br><span class="line">$ git add &lt; filename &gt;</span><br><span class="line"><span class="comment"># 添加所有更改的文件</span></span><br><span class="line">$ git add .</span><br><span class="line"><span class="comment"># 交互式添加文件</span></span><br><span class="line">$ git add -p</span><br></pre></td></tr></table></figure>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br><span class="line">$ git commit -m <span class="string">&quot;测试提交&quot;</span></span><br><span class="line"><span class="comment"># 注意此操作会重写之前的提交</span></span><br><span class="line">$ git commit -m <span class="string">&quot;测试提交&quot;</span> --amend</span><br></pre></td></tr></table></figure>
<h1 id="忽略特定的文件"><a href="#忽略特定的文件" class="headerlink" title="忽略特定的文件"></a>忽略特定的文件</h1><p>可以配置 Git 忽略特定的文件或者是文件夹。这些配置都放在 “<code>.gitignore</code>” 文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 工作目录下的 gitignore，对所有的 clone 有效</span></span><br><span class="line">/.gitignore</span><br><span class="line"><span class="comment"># 用户全局 gitignore，只对当前的用户有效</span></span><br><span class="line">~/.gitignore_global</span><br><span class="line"><span class="comment"># 项目目录下的 gitignore ，只对当前的 clone 有效(你也可以使用配置变量 `core.excludesfile`)</span></span><br><span class="line"><span class="variable">$GIT_DIR</span>/info/exclude</span><br></pre></td></tr></table></figure><br>忽略已被跟踪的文件的更改<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略某个文件的变更</span></span><br><span class="line">$ git update-index --assume-unchanged</span><br><span class="line"><span class="comment"># 去取消忽略某个文件的变更</span></span><br><span class="line">$ git update-index --no-assume-unchanged</span><br><span class="line"><span class="comment"># 列出所有被 `assume-unchanged` 的文件</span></span><br><span class="line">$ git ls-files -v | grep <span class="string">&#x27;^h&#x27;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>拓展阅读<br><a href="https://git-scm.com/docs/git-ls-files">git-ls-files</a></p>
</blockquote>
<h1 id="储藏与取出储藏"><a href="#储藏与取出储藏" class="headerlink" title="储藏与取出储藏"></a>储藏与取出储藏</h1><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 储藏当前所有的未提交 回到 HEAD 的状态</span></span><br><span class="line">$ git stash </span><br><span class="line"><span class="comment"># 还原一个储藏，如不指定则为最后一个储藏</span></span><br><span class="line">$ git stash apply  &lt;stash@&#123;1&#125;&gt;</span><br><span class="line"><span class="comment"># 储藏列表</span></span><br><span class="line">$ git stash list</span><br><span class="line"><span class="comment"># 还原最后一个储藏，并将其从 list 中删除</span></span><br><span class="line">$ git stash pop</span><br><span class="line"><span class="comment"># 清空所有储藏</span></span><br><span class="line">$ git stash clear</span><br></pre></td></tr></table></figure>
<h1 id="检查仓库状态"><a href="#检查仓库状态" class="headerlink" title="检查仓库状态"></a>检查仓库状态</h1><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h2><p>用法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><br><img src="/uploads/git-tutorials/git-status-screenshots.png" alt="git入门教程"></p>
<ul>
<li>new file：新文件</li>
<li>modified：修改的文件</li>
<li>deleted：删除的文件</li>
<li>Untracked file：未跟踪的文件</li>
</ul>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用默认格式显示完整地项目历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line"><span class="comment">#搜索特定作者的提交。`&lt;pattern&gt;` 可以是字符串或正则表达式。</span></span><br><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">&quot;&lt;pattern&gt;&quot;</span></span><br><span class="line"><span class="comment">#搜索提交信息匹配特定 `&lt;pattern&gt;` 的提交。`&lt;pattern&gt;` 可以是字符串或正则表达式。</span></span><br><span class="line">$ git <span class="built_in">log</span> --grep=<span class="string">&quot;&lt;pattern&gt;&quot;</span></span><br><span class="line"><span class="comment">#只显示发生在 `&lt;since&gt;` 和 `&lt;until&gt;` 之间的提交。两个参数可以是提交 ID、分支名、`HEAD` 或是任何一种引用。</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;since&gt;..&lt;until&gt;</span><br><span class="line"><span class="comment">#只显示包含特定文件的提交。查找特定文件的历史这样做会很方便。</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h2 id="检出之前的提交"><a href="#检出之前的提交" class="headerlink" title="检出之前的提交"></a>检出之前的提交</h2><p><code>git checkout</code> 这个命令有三个不同的作用：<strong>检出文件</strong>、<strong>检出提交</strong>和<strong>检出分支</strong>。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件之前的版本。它将工作目录中的 `&lt;file&gt;` 文件变成 `&lt;commit&gt;` 中那个文件的拷贝，并将它加入缓存区。</span></span><br><span class="line">$ git checkout &lt;commit&gt; &lt;file&gt;</span><br><span class="line"><span class="comment"># 更新工作目录中的所有文件，使得和某个特定提交中的文件一致。</span></span><br><span class="line">$ git checkout &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="回滚错误的修改"><a href="#回滚错误的修改" class="headerlink" title="回滚错误的修改"></a>回滚错误的修改</h1><h2 id="git-revert-和-git-reset"><a href="#git-revert-和-git-reset" class="headerlink" title="git revert 和 git reset"></a><code>git revert</code> 和 <code>git reset</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来撤销一个已经提交的快照。</span></span><br><span class="line">$ git revert</span><br><span class="line"><span class="comment"># 重置提交</span></span><br><span class="line">$ git reset</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/git-tutorials/git-revert.png" alt="git入门教程"></p>
<p>通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的新提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。<br><br/><br>撤销（revert）应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 <code>git revert</code>，它帮你做了所有的事情。</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a><code>git revert</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑一些文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交一份快照</span></span><br><span class="line">$ git commit -m <span class="string">&quot;做了一些改变&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销刚刚的提交</span></span><br><span class="line">$ git revert HEAD</span><br></pre></td></tr></table></figure>
<p>![)</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><p>和 <code>git checkout</code> 一样，<code>git reset</code> 有很多种用法。它可以被用来移除提交快照。它应该只被用于 _本地_ 修改——你永远不应该重设和其他开发者共享的快照。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从缓存区移除特定文件，但工作目录不变。</span></span><br><span class="line">$ git reset &lt;file&gt;</span><br><span class="line"><span class="comment"># 重设缓冲区，匹配最近的一次提交，但工作目录不变。</span></span><br><span class="line">$ git reset</span><br><span class="line"><span class="comment"># 重设缓冲区和工作目录，匹配最近的一次提交。</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment"># 将当前分支的末端移到 `&lt;commit&gt;`，将缓存区重设到这个提交，但不改变工作目录。</span></span><br><span class="line">$ git reset &lt;commit&gt;</span><br><span class="line"><span class="comment"># 将当前分支的末端移到 `&lt;commit&gt;`，将缓存区和工作目录都重设到这个提交。</span></span><br><span class="line">$ git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="git-revert-和-git-reset的区别"><a href="#git-revert-和-git-reset的区别" class="headerlink" title="git revert 和 git reset的区别"></a><code>git revert</code> 和 <code>git reset</code>的区别</h3><p>撤销(revert)被设计为撤销 _公开_ 的提交的安全方式，<code>git reset</code>被设计为重设 _本地_ 更改。<br>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。</p>
<p><strong>不要重设公共历史</strong> </p>
<p>当有 <code>&lt;commit&gt;</code> 之后的提交被推送到公共仓库后，你绝不应该使用 <code>git reset</code>。发布一个提交之后，你必须假设其他开发者会依赖于它。<br>重点是，确保你只对本地的修改使用 <code>git reset</code>，而不是公共更改。如果你需要修复一个公共提交，<code>git revert</code> 命令正是被设计来做这个的。</p>
<h3 id="取消文件缓存"><a href="#取消文件缓存" class="headerlink" title="取消文件缓存"></a>取消文件缓存</h3><p><code>git reset</code> 命令在准备缓存快照时经常被用到。下面的例子假设你有两个文件，<code>hello.js</code> 和 <code>main.js</code>它们已经被加入了仓库中。</p>
<ul>
<li>例1<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑了hello.js和main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存了目录下所有文件</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 意识到hello.js和main.js中的修改应该在不同的快照中提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消main.js缓存</span></span><br><span class="line">$ git reset main.js</span><br><span class="line"><span class="comment"># 只提交hello.js</span></span><br><span class="line">$ git commit -m <span class="string">&quot;在hello.js做了一些改变&quot;</span></span><br><span class="line"><span class="comment"># 在另一份快照中提交main.js</span></span><br><span class="line">$ git add main.js</span><br><span class="line">$ git commit -m <span class="string">&quot;编辑 main.js&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>例2<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个叫`foo.js`的新文件，增加代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到项目历史</span></span><br><span class="line">$ git add foo.js</span><br><span class="line">$ git commit -m <span class="string">&quot;开始开发一个屌爆了的功能&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次编辑`foo.js`，修改其他文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交另一份快照</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;添加了屌炸了的功能&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 决定废弃这个功能，并删除相关的更改</span></span><br><span class="line">$ git reset --hard HEAD~2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a><code>git clean</code></h2><p><code>git clean</code> 命令将未跟踪的文件从你的工作目录中移除。他和<code>rm</code>一样，只是提供了一条捷径。<br><code>git clean</code> 命令经常和 <code>git reset --hard</code> 一起使用。<code>reset</code> 只影响被跟踪的文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 告诉你那些文件在命令执行后会被移除，而不是真的删除它。</span></span><br><span class="line">$ git clean -n</span><br><span class="line"><span class="comment"># 移除当前目录下未被跟踪的文件</span></span><br><span class="line">$ git clean -f</span><br><span class="line"><span class="comment"># 移除未跟踪的文件，但限制在某个路径下。</span></span><br><span class="line">$ git clean -f &lt;path&gt;</span><br><span class="line"><span class="comment"># 移除未跟踪的文件，以及目录。</span></span><br><span class="line">$ git clean -df</span><br></pre></td></tr></table></figure></p>
<p>如果你在本地仓库中作死之后想要毁尸灭迹，<code>git reset --hard</code> 和 <code>git clean -f</code> 是你最好的选择。运行这两个命令使工作目录和最近的提交保持一致，让你在干净的状态下继续工作。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑了一些文件</span></span><br><span class="line"><span class="comment"># 新增了一些文件</span></span><br><span class="line"><span class="comment"># 发现有点问题需要 &quot;回滚&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将跟踪的文件回滚回去</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除未跟踪的文件</span></span><br><span class="line">$ git clean -df</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>移除当前目录下未被跟踪的文件。<code>-f</code>（强制）标记是必需的，除非 <code>clean.requireForce</code> 配置项被设为了 <code>false</code>（默认为 <code>true</code>）。它 _不会_ 删除 <code>.gitignore</code> 中指定的未跟踪的文件。</p>
</blockquote>
<h1 id="重写项目历史"><a href="#重写项目历史" class="headerlink" title="重写项目历史"></a>重写项目历史</h1><h2 id="git-commit-amend"><a href="#git-commit-amend" class="headerlink" title="git commit --amend"></a><code>git commit --amend</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>![)</p>
<blockquote>
<p>注意 <strong>不要修复公共提交</strong><br>修复过的提交事实上是全新的提交，之前的提交会被移除出项目历史。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 hello.js 和 main.js</span></span><br><span class="line">$ git add hello.js</span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 意识到你忘记添加 main.js 的更改</span></span><br><span class="line">$ git add main.js</span><br><span class="line">$ git commit --amend --no-edit</span><br></pre></td></tr></table></figure>
<p>加入 <code>--no-edit</code> 标记会修复提交但不修改提交信息。</p>
<blockquote>
<p><code>git commit --amend</code> 命令是修复最新提交的便捷方式。amend 不只是修改了最新的提交——它进行了一次替换。</p>
</blockquote>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a><code>git rebase</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前分支 rebase 到 `&lt;base&gt;`</span></span><br><span class="line">$ git rebase &lt;base&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以是任何类型的提交引用（ID、分支名、标签，或是 <code>HEAD</code> 的相对引用）。</p>
</blockquote>
<p>rebase 的主要目的是为了保持一个线性的项目历史。</p>
<p><img src="/uploads/git-tutorials/git-rebase-1.png" alt="git入门教程"><br>要将你的 feature 分支整合进 master 分支，你有两个选择：直接 merge，或者先 rebase 后 merge。前者会产生一个三路合并（3-way merge）和一个合并提交，而后者产生的是一个快速向前的合并以及完美的线性历史。下图展示了为什么 rebase 到 master 分支会促成一个快速向前的合并。<br>![)<br>rebase 是将上游更改合并进本地仓库的通常方法。你每次想查看上游进展时，用 git merge 拉取上游更新会导致一个多余的合并提交。在另一方面，rebase 就好像是说「我想将我的更改建立在其他人的进展之上」。</p>
<blockquote>
<p>注意 <strong>不要 rebase 公共历史</strong></p>
</blockquote>
<h3 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a><code>git rebase -i</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick fc62e55 added:file_size</span><br><span class="line">pick 9824bf4 fixed:little thing</span><br><span class="line">pick 21d80a5 added:number to <span class="built_in">log</span></span><br><span class="line">pick 76b9da6 added:the apply <span class="built_in">command</span></span><br><span class="line">pick c264051 Revert:<span class="string">&quot;added file_size&quot;</span> - not implemented correctly</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase f408319..b04dc3d onto f408319</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick = use commit</span></span><br><span class="line"><span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># d, drop = remove commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这些信息表示从你上一次推送操作起有5个提交。每个提交都用一行来表示，行格式如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(action) (partial-sha) (short commit message)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果指定进行’pick’操作，git会以同样的提交信息（commit message）保存提交</li>
<li>如果指定进行’reword’操作，git会保存提交，但是会停下来修改提交信息（commit message）</li>
<li>如果指定进行’edit’操作，git会完成同样的工作，但是在对下一提交进行操作之前，它会返回到命令行让你对提交进行修正，或者对提交内容进行修改。</li>
<li>如果指定进行’squash’操作，git会把这个提交和前一个提交合并成为一个新的提交</li>
<li>如果指定进行’fixup’操作，但是丢弃提交的日志信息</li>
<li>如果指定进行’exec’操作，使用 shell 执行命令</li>
<li>如果指定进行’drop’操作，删除此次提交</li>
</ul>
<p>更改完成之后<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></p>
<h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a><code>git reflog</code></h2><p>Git 用引用日志这种机制来记录分支顶端的更新。</p>
<p>每次当前的 HEAD 更新时（如切换分支、拉取新更改、重写历史或只是添加新的提交），引用日志都会添加一个新条目。</p>
<p>🌰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/git-tutorials/git-reflog.png" alt="git入门教程"><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 9d43f81</span><br></pre></td></tr></table></figure><br>使用 <code>git reset</code>，就有可能能将master变回之前的那个提交。</p>
<p><strong>务必记住</strong>，引用日志提供的安全网只对提交到本地仓库的更改有效</p>
<h1 id="保持同步"><a href="#保持同步" class="headerlink" title="保持同步"></a>保持同步</h1><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><code>git remote</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示你和其他远程仓库的连接。</span></span><br><span class="line">$ git remote</span><br><span class="line"><span class="comment"># 和上个命令相同，并且同时显示每个连接的 URL。</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 创建一个新的远程仓库连接。</span></span><br><span class="line">$ git remote add &lt;name&gt; &lt;url&gt;</span><br><span class="line"><span class="comment"># 移除名为 &lt;name&gt; 的远程仓库的连接。</span></span><br><span class="line">$ git remote rm &lt;name&gt;</span><br><span class="line"><span class="comment"># 重命名远程连接</span></span><br><span class="line">$ git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你用 <code>git clone</code> 克隆仓库时，它会自动创建了一个名为 origin 的远程连接，指向被克隆的仓库。</p>
</blockquote>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><code>git fetch</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。</span></span><br><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"><span class="comment"># 和上一个命令相同，但只拉取指定的分支。</span></span><br><span class="line">$ git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>🌰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/git-tutorials/git-fetch.png" alt="git入门教程"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 master 与 origin/master 的区别</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline master..origin/master</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">$ git merge origin/master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">$ git fetch &amp;&amp; git merge</span><br></pre></td></tr></table></figure>
<p>用法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取当前分支对应的远程副本中的更改，并立即并入本地副本。</span></span><br><span class="line">$ git pull &lt;remote&gt;</span><br><span class="line"><span class="comment"># 效果等同于</span></span><br><span class="line">$ git fetch &amp;&amp; git merge origin/.</span><br><span class="line"><span class="comment"># 使用 `git rebase` 合并远程分支和本地分支，而不是使用 `git merge`。</span></span><br><span class="line">$ git pull --rebase &lt;remote&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>--rebase</code> 标记可以用来保证线性的项目历史，防止合并提交（merge commits）的产生。很多开发者倾向于使用 rebase 而不是 merge，因为「我想要把我的更改放在其他人完成的工作之后」。</p>
</blockquote>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><code>git push</code></h2><p>Push 是你将本地仓库中的提交转移到远程仓库中时要做的事。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将指定的分支推送到 `&lt;remote&gt;` 上</span></span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"><span class="comment"># 强制推送</span></span><br><span class="line">$ git push &lt;remote&gt; --force</span><br><span class="line"><span class="comment"># 将所有本地分支推送到指定的远程仓库。</span></span><br><span class="line">$ git push &lt;remote&gt; --all</span><br><span class="line"><span class="comment"># 当你推送一个分支或是使用 `--all` 选项时，标签不会被自动推送上去。`--tags` 将你所有的本地标签推送到远程仓库中去。</span></span><br><span class="line">$ git push &lt;remote&gt; --tags</span><br></pre></td></tr></table></figure></p>
<h3 id="将本地提交推送到中央仓库的一些标准做法。"><a href="#将本地提交推送到中央仓库的一些标准做法。" class="headerlink" title="将本地提交推送到中央仓库的一些标准做法。"></a>将本地提交推送到中央仓库的一些标准做法。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 master 分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># fetch 远程分支的代码</span></span><br><span class="line">$ git fetch origin master</span><br><span class="line"><span class="comment"># 変基到 origin/master</span></span><br><span class="line">$ git rebase -i origin/master</span><br><span class="line"><span class="comment"># Squash commits, fix up commit messages etc.</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为我们已经确信本地的 <code>master</code> 分支是最新的，它应该导致快速向前的合并，<code>git push</code> 不应该抛出非快速向前之类的问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出仓库中所有分支。</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 创建一个名为 `&lt;branch&gt;` 的分支，__不会__ 自动切换到那个分支去</span></span><br><span class="line">$ git branch &lt;branch&gt;</span><br><span class="line"><span class="comment"># 删除指定分支。这是一个安全的操作，Git 会阻止你删除包含未合并更改的分支。</span></span><br><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"><span class="comment"># 强制删除指定分支，即使包含未合并更改。</span></span><br><span class="line">$ git branch -D &lt;branch&gt;</span><br><span class="line"><span class="comment"># 将当前分支命名为 `&lt;branch&gt;`</span></span><br><span class="line">$ git branch -m &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h1><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定分支，分支应该已经通过 `git branch` 创建。之后 `&lt;existing-branch&gt;` 成为当前的分支，并更新工作目录的版本。</span></span><br><span class="line">$ git checkout &lt;existing-branch&gt;</span><br><span class="line"><span class="comment"># 创建一个名为 `&lt;branch&gt;` 的分支，__不会__ 自动切换到那个分支去</span></span><br><span class="line">$ git checkout -b &lt;new-branch&gt;</span><br><span class="line"><span class="comment"># 与上一条命令相同，只是将 `&lt;existing-branch&gt;` 作为新分支的基，而不是当前分支。</span></span><br><span class="line">$ git checkout -b &lt;new-branch&gt; &lt;existing-branch&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a><code>git merge</code></h2><p>合并是 Git 将被 fork 的历史放回到一起的方式。<code>git merge</code> 命令允许你将 <code>git branch</code> 创建的多条分支合并成一个。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/uploads/git-tutorials/git-merge.png" alt="git入门教程"></p>
<h1 id="Git-cheat-sheet"><a href="#Git-cheat-sheet" class="headerlink" title="Git cheat sheet"></a>Git cheat sheet</h1><p>最后附上<a href="https://www.atlassian.com/dam/jcr:8132028b-024f-4b6b-953e-e68fcce0c5fa/atlassian-git-cheatsheet.pdf">cheat sheet 下载链接</a></p>
<h1 id="参考文章列表"><a href="#参考文章列表" class="headerlink" title="参考文章列表"></a>参考文章列表</h1><ul>
<li><a href="https://git-scm.com/book/en/v2">git book</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/">git-recipes BY 童仲毅（geeeeeeeeek@github）</a></li>
<li><a href="https://www.atlassian.com/git/tutorials">atlassian git tutorials</a></li>
<li><a href="https://github.com/sparkbox/standard/blob/master/style/git/.gitmessage">sparkbox/standard/style/git/.gitmessage</a></li>
<li><a href="http://www.infoq.com/cn/news/2016/01/12-git-advanced-commands">你需要知道的12个Git高级命令</a></li>
<li><a href="https://stackoverflow.com/questions/11041729/why-does-github-recommend-https-over-ssh">Why does GitHub recommend HTTPS over SSH?</a></li>
<li><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>入门教程</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 指南</title>
    <url>/typescirpt-guide/</url>
    <content><![CDATA[<h3 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h3><blockquote>
<h3 id="TypeScript-is-JavaScript-with-syntax-for-types"><a href="#TypeScript-is-JavaScript-with-syntax-for-types" class="headerlink" title="TypeScript is JavaScript with syntax for types."></a>TypeScript is JavaScript with syntax for types.</h3><p>TypeScript is a strongly typed programming language which builds on JavaScript giving you better tooling at any scale.</p>
<p>@typescriptlang 官网</p>
</blockquote>
<p><del>TypeScript 是 JavaScript 的超集</del></p>
<p>TypeScript 是具有类型语法的 JavaScript。</p>
<p>TypeScript 是一种建立在 JavaScript 之上的强类型编程语言，可为您提供任何规模的更好工具。</p>
<span id="more"></span>
<h4 id="Typescript-提供什么类型能力？"><a href="#Typescript-提供什么类型能力？" class="headerlink" title="Typescript 提供什么类型能力？"></a>Typescript 提供什么类型能力？</h4><ul>
<li>在开发过程中，配合 IDE，TS 能实时检查类型的合法性，还能基于类型给出更精准的自动补全等特征提升码字效率。</li>
<li>在编译过程中，TS 仍然能做类型检查，再把 TS 代码编译成 JS 代码。</li>
</ul>
<p>####　 TypeScript 与 JavaScript 的区别</p>
<table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>具有类型语法的 JavaScript，用于解决大型项目代码复杂性</td>
<td>一种脚本语言，用于创建动态网页</td>
</tr>
<tr>
<td>可以在编译期间发现并纠正错误</td>
<td>作为一种解释性语言，只能在运行时发现错误</td>
</tr>
<tr>
<td>强类型，支持静态和动态类型</td>
<td>弱类型，没有静态类型选项</td>
</tr>
<tr>
<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>
<td>可以直接在浏览器中使用</td>
</tr>
<tr>
<td>支持模块、接口和泛型</td>
<td>有限支持模块、不支持泛型和接口</td>
</tr>
<tr>
<td>支持 ES3、ES3、ES5 及 ES2015+、 ESNext</td>
<td>不支持编译 ES3、ES3、ES5 及 ESNext</td>
</tr>
</tbody>
</table>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">const</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line"><span class="keyword">const</span> cout: <span class="built_in">number</span> = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">const</span> name: <span class="built_in">string</span> = <span class="string">&#x27;Godfery&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt</span></span><br><span class="line"><span class="keyword">const</span> theBiggestInt: <span class="built_in">BigInt</span> = <span class="number">9007199254740991n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbole</span></span><br><span class="line"><span class="keyword">const</span> privateKey: <span class="built_in">Symbol</span> = <span class="built_in">Symbol</span>(<span class="string">&#x27;_key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用 <code>const</code>、<code>let</code>、<code>var</code>声明变量时，可以选择添加「类型注解」指定变量的类型。</p>
</blockquote>
<h4 id="数组-元祖"><a href="#数组-元祖" class="headerlink" title="数组/元祖"></a>数组/元祖</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">const</span> Fruits: <span class="built_in">string</span>[] = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> UserNames: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jerry&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tuple</span></span><br><span class="line"><span class="keyword">const</span> entry: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">27</span>];</span><br></pre></td></tr></table></figure>
<h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>在 TypeScript 中，任何类型都可以被归为 <code>any</code> 类型。当你不想写类型声明的时候可以使用它。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 下面的代码不会抛出编译错误</span></span><br><span class="line"><span class="comment">// 使用 `any` 禁用所有的类型检查功能，并且假设您比 TypeScript 更了解环境</span></span><br><span class="line">obj.foo();</span><br><span class="line">obj();</span><br><span class="line">obj.bar = <span class="number">100</span>;</span><br><span class="line">obj = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj;</span><br></pre></td></tr></table></figure>
<h5 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h5><p>当你不指定类型，并且 TypeScript 不能从上下文推断出类型，编译器通常将默认为 <code>any</code>。你通常希望避免这种情况，因为<code>any</code> 不会类型检查。使用<code>noImplicitAny</code>可以配置隐式<code>any</code>类型抛出异常。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当 noImplicitAny 开启时会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(s.subtr(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 <a href="https://www.typescriptlang.org/tsconfig#strict">strict</a> 时，默认为 <code>true</code>，否则默认为 <code>false</code></p>
</blockquote>
<h4 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a><code>null</code> 和 <code>undefined</code></h4><p>JavaScript 有两个原始值用于标明不存在或未初始化的值：<code>null</code>和<code>undefined</code>。TypeScript 也有两个对应同名类型：<code>null</code>和<code>undefined</code>。这些类型的行为如何取决于您是否具有 <a href="https://www.typescriptlang.org/tsconfig/#strictNullChecks">strictNullChecks</a> 选项。</p>
<h5 id="strictNullChecks-on-（默认）"><a href="#strictNullChecks-on-（默认）" class="headerlink" title="strictNullChecks on （默认）"></a><code>strictNullChecks</code> on （默认）</h5><p>当一个值为<code>null</code>或<code>undefined</code> ，你需要在使用属性或方法前检查这些值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 什么都不做</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span> + x.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="strictNullChecks-off"><a href="#strictNullChecks-off" class="headerlink" title="strictNullChecks off"></a><code>strictNullChecks</code> off</h5><p>值为<code>null</code>或<code>undefined</code>仍然可以正常的访问。且可以将 <code>null</code>和<code>undefined</code>赋值给任意类型。</p>
<h5 id="非空断言运算符（！后缀）"><a href="#非空断言运算符（！后缀）" class="headerlink" title="非空断言运算符（！后缀）"></a>非空断言运算符（<code>！</code>后缀）</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liveDangerously</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 没有错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(x!.toFixed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：就像其他类型断言一样，这并不会改变代码运时的行为。所以请只在你确定值不会是<code>null</code> 或<code>undefined</code>的时候使用<code>!</code></p>
</blockquote>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数的类型注解对象类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCoord</span>(<span class="params">pt: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;坐标的 X 值是&#x27;</span> + pt.x);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;坐标的 Y 值是&#x27;</span> + pt.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">obj: &#123; first: <span class="built_in">string</span>; last?: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 错误 当 `obj.last` 没有提供可能会崩溃</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.last.toUpperCase());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 `obj.last` 为 undefined 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (obj.last !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj.last.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用现代 JavaScript 语法的一种安全的替代写法</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.last?.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全都是对的</span></span><br><span class="line">printName(&#123; <span class="attr">first</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;);</span><br><span class="line">printName(&#123; <span class="attr">first</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Alisson&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以用使用<code>;</code>或者<code>,</code>来分割属性，并且最后一个分隔符通常是可一省略的。</p>
</blockquote>
<h5 id="readonly属性"><a href="#readonly属性" class="headerlink" title="readonly属性"></a><code>readonly</code>属性</h5><p>TypeScript 中可以标记属性为 <code>readonly</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">  <span class="keyword">readonly</span> prop: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">obj: SomeType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们可以读取 &#x27;obj.prop&#x27;.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`prop has the value &#x27;<span class="subst">$&#123;obj.prop&#125;</span>&#x27;.`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是为 &#x27;prop&#x27; 不能重新赋值 因为它是只读属性</span></span><br><span class="line">  obj.prop = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="comment">// Error: Cannot assign to &#x27;prop&#x27; because it is a read-only property.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h5><p>有些时候你一开始并不知道所有类型属性的<code>names</code>，但是你知道 <code>values</code> 的类型。这时你可以使用索引签名来描述可能的值的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myArray: StringArray = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> secondItem = myArray[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td>有函数类型</td>
<td>无函数类型</td>
</tr>
<tr>
<td>含有类型检查</td>
<td>无类型</td>
</tr>
<tr>
<td>箭头函数</td>
<td>箭头函数（ES2015+）</td>
</tr>
<tr>
<td>必填和可选参数</td>
<td>所有参数都是可选的</td>
</tr>
<tr>
<td>默认参数</td>
<td>默认参数</td>
</tr>
<tr>
<td>剩余参数</td>
<td>剩余参数</td>
</tr>
<tr>
<td>有函数重载</td>
<td>无函数重载</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在 JavaScript 中，函数是<strong>头等(</strong>first-class<strong>)</strong>对象，因为它们可以像任何其他<strong>对象</strong>一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是<code>Function</code>对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions">MDN 关于函数的定义</a></p>
</blockquote>
<h5 id="参数类型注解和返回类型注解"><a href="#参数类型注解和返回类型注解" class="headerlink" title="参数类型注解和返回类型注解"></a>参数类型注解和返回类型注解</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数类型注解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span> + name.toUpperCase() + <span class="string">&#x27;!!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型注解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFavoriteNumber</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Sum1 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sum2 &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sum3 = &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum2: Sum2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> sum3: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>
<h5 id="可选参数及默认参数"><a href="#可选参数及默认参数" class="headerlink" title="可选参数及默认参数"></a>可选参数及默认参数</h5><p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要注意的<strong>可选参数必须放在普通参数的后面</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params">name: <span class="built_in">string</span> = <span class="string">&#x27;Semlinker&#x27;</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m.map(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27; 的返回值 [10, 20, 30, 40]</span></span><br><span class="line"><span class="keyword">const</span> a = multiply(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>#####函数重载</p>
<p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">number</span>, b: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.toString() + b.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-和-undefined"><a href="#void-和-undefined" class="headerlink" title="void 和 undefined"></a>void 和 undefined</h5><p>void 表示不返回值的函数的返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里推断返回类型为 void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，一个放回没有返回任何值时，他的返回值就是 undefined。</p>
<blockquote>
<p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：</p>
</blockquote>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code> 类型表示的是那些永不存在的值的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><h4 id="interface-和-type"><a href="#interface-和-type" class="headerlink" title="interface 和 type"></a>interface 和 type</h4><h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0gibz8tyij210y0q4wh4.jpg" alt="interface"></p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0gicedxunj210y0q4gp4.jpg" alt="type"></p>
<h5 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a>type 和 interface 的区别</h5><h6 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  wong();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet];</span><br></pre></td></tr></table></figure>
<p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure>
<p>其他骚操作</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;</span><br><span class="line"><span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> Pair&lt;T&gt; = [T, T];</span><br><span class="line"><span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; <span class="attr">left</span>: Tree&lt;T&gt;; right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>
<h6 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h6><p>类型合并</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  sex: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User 接口为 &#123;</span></span><br><span class="line"><span class="comment">  name: string</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">  sex: string</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><h5 id="类的属性和方法"><a href="#类的属性和方法" class="headerlink" title="类的属性和方法"></a>类的属性和方法</h5><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。<br>在 TypeScript 中，我们可以通过 Class 关键字来定义一个类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> cname: <span class="built_in">string</span> = <span class="string">&#x27;Greeter&#x27;</span>;</span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Greeter = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  Greeter.getClassName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  Greeter.cname = <span class="string">&#x27;Greeter&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> Greeter;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h6><p>我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;Hello TypeScript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;Hello TypeScript&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._fullName = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">&#x27;Semlinker&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p>继承 (Inheritance) 是一种联结类与类的层次模型。<br>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p>
<p>继承是一种 <a href="https://zh.wikipedia.org/wiki/Is-a">is-a</a> 关系：<br><img src="https://static001.geekbang.org/infoq/66/667e49e2bb0f13ace5645025ae09185e.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="is-a"></p>
<p>在 TypeScript 中，可以通过 extends 关键字来实现继承：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line"></span><br><span class="line">  constructor(theName: string) &#123;</span><br><span class="line">    this.name &#x3D; theName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move(distanceInMeters: number &#x3D; 0) &#123;</span><br><span class="line">    console.log(&#96;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move(distanceInMeters &#x3D; 5) &#123;</span><br><span class="line">    console.log(&quot;Slithering...&quot;);</span><br><span class="line">    super.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam &#x3D; new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">sam.move();</span><br></pre></td></tr></table></figure>
<h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>使用枚举我们可以定义一些带名字的常量。 TypeScript 支持数字的和基于字符串的枚举。</p>
<h5 id="数字枚举值"><a href="#数字枚举值" class="headerlink" title="数字枚举值"></a>数字枚举值</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure>
<p>看一下编译结果</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;NORTH&#x27;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;SOUTH&#x27;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&#x27;EAST&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;EAST&#x27;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&#x27;WEST&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEST&#x27;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长，也可以手动设置枚举值的初始值。enum 会为数字类型的枚举设置“反向映射”，也就是为对应的值，设置他们的 key。所以数字类型的枚举值，可以用其对应的值，取到 key。</p>
<h5 id="字符串枚举值"><a href="#字符串枚举值" class="headerlink" title="字符串枚举值"></a>字符串枚举值</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH = <span class="string">&#x27;NORTH&#x27;</span>,</span><br><span class="line">  SOUTH = <span class="string">&#x27;SOUTH&#x27;</span>,</span><br><span class="line">  EAST = <span class="string">&#x27;EAST&#x27;</span>,</span><br><span class="line">  WEST = <span class="string">&#x27;WEST&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下编译代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="string">&#x27;NORTH&#x27;</span>;</span><br><span class="line">  Direction[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="string">&#x27;SOUTH&#x27;</span>;</span><br><span class="line">  Direction[<span class="string">&#x27;EAST&#x27;</span>] = <span class="string">&#x27;EAST&#x27;</span>;</span><br><span class="line">  Direction[<span class="string">&#x27;WEST&#x27;</span>] = <span class="string">&#x27;WEST&#x27;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>如果使用字符串枚举值，则需要为每个枚举赋值，否则其值为 <code>undefined</code></p>
<h5 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h5><p>异构枚举的成员值是数字和字符串的混合：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C = <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">  D = <span class="string">&#x27;D&#x27;</span>,</span><br><span class="line">  E = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型运算和派生"><a href="#类型运算和派生" class="headerlink" title="类型运算和派生"></a>类型运算和派生</h3><h4 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h4><p>字符串字面量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruits = <span class="string">&#x27;apple&#x27;</span> | <span class="string">&#x27;banana&#x27;</span> | <span class="string">&#x27;orange&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其他字面量类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他字面量类型</span></span><br><span class="line"><span class="keyword">type</span> OneToFive = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">type</span> Bools = <span class="literal">true</span> | <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="模板字面量类型"><a href="#模板字面量类型" class="headerlink" title="模板字面量类型"></a>模板字面量类型</h4><p>模板字面量类型建立在字符串文字类型之上，并且能够通过联合扩展成许多字符串。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EmailLocaleIDs = <span class="string">&#x27;welcome_email&#x27;</span> | <span class="string">&#x27;email_heading&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> FooterLocaleIDs = <span class="string">&#x27;footer_title&#x27;</span> | <span class="string">&#x27;footer_sendoff&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> AllLocaleIDs = <span class="string">`<span class="subst">$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>
<h5 id="内部字符串操作类型"><a href="#内部字符串操作类型" class="headerlink" title="内部字符串操作类型"></a>内部字符串操作类型</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uppercase&lt;StringType&gt;</span></span><br><span class="line"><span class="keyword">type</span> ASCIICacheKey&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`ID-<span class="subst">$&#123;Uppercase&lt;Str&gt;&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">type</span> MainID = ASCIICacheKey&lt;<span class="string">&#x27;my_app&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lowercase&lt;StringType&gt;</span></span><br><span class="line"><span class="keyword">type</span> ASCIICacheKey&lt;Str <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`id-<span class="subst">$&#123;Lowercase&lt;Str&gt;&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">type</span> MainID = ASCIICacheKey&lt;<span class="string">&#x27;MY_APP&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capitalize&lt;StringType&gt;</span></span><br><span class="line"><span class="keyword">type</span> LowercaseGreeting = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> Greeting = Capitalize&lt;LowercaseGreeting&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncapitalize&lt;StringType&gt;</span></span><br><span class="line"><span class="keyword">type</span> UppercaseGreeting = <span class="string">&#x27;HELLO WORLD&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> UncomfortableGreeting = Uncapitalize&lt;UppercaseGreeting&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  a: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Union = A | B | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h5 id="联合类型和守卫"><a href="#联合类型和守卫" class="headerlink" title="联合类型和守卫"></a>联合类型和守卫</h5><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。它包含 3 个要点：可辨识、联合类型和类型守卫。</p>
<h6 id="可辨识"><a href="#可辨识" class="headerlink" title="可辨识"></a>可辨识</h6><p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Motorcycle &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">&#x27;motorcycle&#x27;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: <span class="built_in">number</span>; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Car &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">&#x27;car&#x27;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Truck &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">&#x27;truck&#x27;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: <span class="built_in">number</span>; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分别定义了 <code>Motorcycle</code>、 <code>Motorcycle</code>和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>type</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p>
<h6 id="联合类型-1"><a href="#联合类型-1" class="headerlink" title="联合类型"></a>联合类型</h6><p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：<br>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vehicle = Motorcycle | Car | Truck;</span><br></pre></td></tr></table></figure>
<h6 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (vehicle.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;car&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.transmission * EVALUATION_FACTOR;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;truck&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.capacity * EVALUATION_FACTOR;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;motorcycle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.make * EVALUATION_FACTOR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myTruck: Truck = &#123; <span class="attr">vType</span>: <span class="string">&#x27;truck&#x27;</span>, <span class="attr">capacity</span>: <span class="number">9.5</span> &#125;;</span><br><span class="line">evaluatePrice(myTruck);</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p>
<h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IWorker &#123;</span><br><span class="line">  companyId: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IStaff = IPerson &amp; IWorker;</span><br></pre></td></tr></table></figure>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="keyword">typeof</span> toArray;</span><br></pre></td></tr></table></figure>
<h5 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h5><p><code>keyof</code> 操作符可以用来一个对象中的所有 <code>key</code> 值：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Keys = keyof Person;</span><br></pre></td></tr></table></figure>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p><code>in</code> 用来遍历枚举类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h5><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="索引访问类型"><a href="#索引访问类型" class="headerlink" title="索引访问类型"></a>索引访问类型</h4><p>我们可以使用索引访问类型查找另一个类型的指定属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; alive: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Age = Person[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>
<h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>我们可以借助 <code>extends</code> 关键字实现类似 <code>if</code> 的操作：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  live(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  woof(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example1 = Dog <span class="keyword">extends</span> Animal ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example1 = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example2 = <span class="built_in">RegExp</span> <span class="keyword">extends</span> Animal ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>来个有意思的小例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdLabel &#123;</span><br><span class="line">  id: <span class="built_in">number</span> <span class="comment">/* some fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> NameLabel &#123;</span><br><span class="line">  name: <span class="built_in">string</span> <span class="comment">/* other fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">id: <span class="built_in">number</span></span>): <span class="title">IdLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">NameLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">IdLabel</span> | <span class="title">NameLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">IdLabel</span> | <span class="title">NameLabel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;unimplemented&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以使用该条件类型将重载简化为单个函数，而不需要重载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NameOrId&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? IdLabel : NameLabel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params">idOrName: T</span>): <span class="title">NameOrId</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;unimplemented&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = createLabel(<span class="string">&#x27;typescript&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = createLabel(<span class="number">2.8</span>);</span><br><span class="line"><span class="keyword">let</span> c = createLabel(<span class="built_in">Math</span>.random() ? <span class="string">&#x27;hello&#x27;</span> : <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>另一个例子，我们也可以写一个叫 Flatten 的类型，它把数组类型平坦化为元素类型，但是不使用其他类型:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T;</span><br><span class="line"><span class="keyword">type</span> Str = Flatten&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"><span class="keyword">type</span> Num = Flatten&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>
<h5 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h5><p>条件类型为我们提供了一种使用 <code>infer</code> 关键字从真实分支中比较的类型推断出结果的方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;Type&gt; = Type <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;infer Item&gt; ? Item : Type;</span><br></pre></td></tr></table></figure>
<p>我们可以利用 <code>infer</code> 关键字编写一些有用的 helper 类型别名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GetReturnType&lt;Type&gt; = Type <span class="keyword">extends</span> (...args: <span class="built_in">never</span>[]) =&gt; infer Return ? Return : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Num = GetReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Str = GetReturnType&lt;<span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Bools = GetReturnType&lt;<span class="function">(<span class="params">a: <span class="built_in">boolean</span>, b: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>[]&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>映射类型建立在索引签名的语法之上，索引签名用于声明未提前声明的属性类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OnlyBoolsAndHorses = &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | Horse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>映射类型是一种泛型类型，它使用 PropertyKeys (通常通过 keyof 创建)的联合来迭代键以创建类型:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionsFlags&lt;Type&gt; = &#123;</span><br><span class="line">  [Property <span class="keyword">in</span> keyof Type]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在本例中，OptionsFlags 将获取 Type 类型中的所有属性，并将其值更改为布尔值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FeatureFlags = &#123;</span><br><span class="line">  darkMode: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  newUserProfile: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;</span><br></pre></td></tr></table></figure>
<h5 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h5><p>在映射过程中可以使用两个额外的修饰符: <code>readonly</code> 和 <code>?</code> ，它们分别影响可变性和可选性。<br>您可以通过使用 <code>-</code> 或 <code>+</code> 作为前缀来删除或添加这些修饰符。如果您没有添加前缀，则假定为 <code>+</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CreateMutable&lt;Type&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [Property <span class="keyword">in</span> keyof Type]: Type[Property];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LockedAccount = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnlockedAccount = CreateMutable&lt;LockedAccount&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 - 移除 可选性</span></span><br><span class="line"><span class="keyword">type</span> Concrete&lt;Type&gt; = &#123;</span><br><span class="line">  [Property <span class="keyword">in</span> keyof Type]-?: Type[Property];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaybeUser = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User = Concrete&lt;MaybeUser&gt;;</span><br></pre></td></tr></table></figure>
<p>在 TypeScript 4.1 及以后的版本中，您可以使用映射类型中的 as 子句重新映射映射类型中的键:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MappedTypeWithNewProperties&lt;Type&gt; = &#123;</span><br><span class="line">  [Properties <span class="keyword">in</span> keyof Type <span class="keyword">as</span> NewKeyType]: Type[Properties];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以利用一些特性，比如模板字面量类型，从以前的属性中创建新的属性名:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Getters&lt;Type&gt; = &#123;</span><br><span class="line">  [Property <span class="keyword">in</span> keyof Type <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> Type[Property];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LazyPerson = Getters&lt;Person&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://xie.infoq.cn/article/fcac0b4cad47bb74c898b2b0d?y=qun0703">了不起的 TypeScript 入门教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/lXB55Wl32lhRMhIcrBJJwg?utm_source=pocket_mylist">从零成为 TypeScript 体操运动员，高级类型完全指南</a></li>
<li><a href="https://ts.xcatliu.com/introduction/index.html">TypeScript 入门教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/IIRlhUNCV-hh14FrFDnaTQ?utm_source=pocket_mylist">【第 2425 期】浅谈 Typescript（二）：基础类型和类型的声明、运算、派生</a></li>
<li><a href="https://juejin.cn/post/7000360236372459527">TypeScript 的另一面：类型编程（2021 重制版）</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/intro.html">TypeScript Handbook</a></li>
<li><a href="https://juejin.cn/post/6844903749501059085#heading-5">Typescript 中的 interface 和 type 到底有什么区别</a></li>
</ul>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘命名函数表达式</title>
    <url>/%E6%8F%AD%E7%A7%98%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上还没用发现有人对命名函数表达式进去重复深入的讨论，正因为如此，网上出现了各种各样的误解，本文将从原理和实践两个方面来探讨<code>JavaScript</code>关于命名函数表达式的优缺点。<br>简单的说，命名函数表达式只有一个用户，那就是在==Debug==或者==Profiler==分析的时候来描述函数的名称，也可以使用函数名实现递归，但很快你就会发现其实是不切实际的。当然，如果你不关注调试，那就没什么可担心的了，否则，如果你想了解兼容性方面的东西的话，你还是应该继续往下看看。<br>我们先开始看看，什么叫函数表达式，然后再说一下现代调试器如何处理这些表达式，如果你已经对这方面很熟悉的话，请直接跳过此小节。<br>本文中后半部分说了好多JScript,基本上是过时的东西，我觉得直接略过就行</p>
<span id="more"></span>
<h1 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h1><p>在<code>ECMAScript</code>中，创建函数的最常用的两个方法是<strong>函数表达式</strong>和<strong>函数声明</strong>，两者期间的区别是有点晕，因为<code>ECMAScript</code>规范只明确了一点：函数声明必须带有标示符（==Identifier==）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：</p>
<ol>
<li>函数声明:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名称 (<span class="params">参数：可选</span>)</span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure></li>
<li>函数表达式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名称（可选）(<span class="params">参数：可选</span>)</span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？==ECMAScript==是通过上下文来区分的，如果<code>function foo()&#123;&#125;</code>是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果<code>function foo()&#123;&#125;</code>被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是程序的一部分</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是new表达式</span></span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是函数体的一部分</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>还有一种函数表达式不太常见，就是被括号括住的<code>(function foo()&#123;&#125;)</code>，他是表达式的原因是因为括号 <code>()</code>是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// 函数表达式：包含在分组操作符内</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    (<span class="keyword">var</span> x = <span class="number">5</span>); <span class="comment">// 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：<code>eval(&#39;(&#39; + json + &#39;)&#39;)</code>，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;x&quot;</span>: <span class="number">5</span> &#125;; <span class="comment">// &quot;&#123;&quot; 和 &quot;&#125;&quot; 做解析成代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(&#123; <span class="string">&quot;x&quot;</span>: <span class="number">5</span> &#125;); <span class="comment">// 分组操作符强制将&quot;&#123;&quot; 和 &quot;&#125;&quot;作为对象字面量来解析</span></span><br></pre></td></tr></table></figure>
<p>表达式和声明存在着十分微妙的差别，首先，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(fn());</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，还有一点需要提醒一下，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="comment">// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相反，这样情况，我们要用函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;first&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>函数声明的实际规则如下：</p>
<blockquote>
<p>函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。</p>
</blockquote>
<h1 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h1><p>在ECMAScript的语法扩展中，有一个是函数语句，目前只有基于<a href="http://baike.baidu.com/link?url=gre8zdQLIoY1uzdgpsokc6hMoV8Uh2IaunRbQ-DyvWG2HusZUT2XFEcRKKvF997lPyxLi8EsBYRuOhMo0sRGea">Gecko</a>的浏览器实现了该扩展，所以对于下面的例子，我们仅是抱着学习的目的来看，一般来说不推荐使用（除非你针对Gecko浏览器进行开发）。</p>
<ol>
<li><p>一般语句能用的地方，函数语句也能用，当然也包括Block块中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数语句可以像其他语句一样被解析，包含基于条件执行的情形</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 注：其它客户端会将foo解析成函数声明</span></span><br><span class="line"><span class="comment">// 因此，第二个foo会覆盖第一个，结果返回2，而不是1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在（下一小节我们将会展示命名函数表达式的具体行为）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此刻，foo还没用声明</span></span><br><span class="line"><span class="keyword">typeof</span> foo; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 进入这里以后，foo就被声明在整个作用域内了</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从来不会走到这里，所以这里的foo也不会被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> foo; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<p>不过，我们可以使用下面这样的符合标准的代码来模式上面例子中的函数语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数语句和函数声明（或命名函数表达式）的字符串表示类似，也包括标识符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(foo); <span class="comment">// function foo() &#123; return 1; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另外一个，早期基于<a href="http://baike.baidu.com/link?url=gre8zdQLIoY1uzdgpsokc6hMoV8Uh2IaunRbQ-DyvWG2HusZUT2XFEcRKKvF997lPyxLi8EsBYRuOhMo0sRGea">Gecko</a>的实现（Firefox 3及以前版本）中存在一个bug，即函数语句覆盖函数声明的方式不正确。在这些早期的实现中，函数语句不知何故不能覆盖函数声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 用函数语句重写</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// FF3以下返回1，FF3.5以上返回2</span></span><br><span class="line"><span class="comment">// 不过，如果前面是函数表达式，则没用问题</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 所有版本都返回2</span></span><br></pre></td></tr></table></figure>
<p>再次强调一点，上面这些例子只是在某些浏览器支持，所以推荐大家不要使用这些，除非你就在特性的浏览器上做开发。</p>
</li>
</ol>
<h1 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h1><p>函数表达式在实际应用中还是很常见的，在web开发中友个常用的模式是基于对某种特性的测试来伪装函数定义，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/)</span></span><br><span class="line"><span class="keyword">var</span> contains = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.compareDocumentPosition != <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (el.compareDocumentPosition(b) &amp; <span class="number">16</span>) !== <span class="number">0</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.contains != <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> el !== b &amp;&amp; el.contains(b);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (el === b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (el != b &amp;&amp; (b = b.parentNode) != <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span> el === b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> foo; <span class="comment">// foo是在内部作用域内有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// foo在外部用于是不可见的</span></span><br><span class="line"><span class="keyword">typeof</span> foo; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">f(); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><br>既然，这么要求，那命名函数表达式到底有啥用啊？为啥要取名？<br>正如我们开头所说：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。</p>
<h1 id="调试器中的函数名"><a href="#调试器中的函数名" class="headerlink" title="调试器中的函数名"></a>调试器中的函数名</h1><p>如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里我们使用了3个带名字的函数声明</span></span><br><span class="line"><span class="comment">// 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了</span></span><br><span class="line"><span class="comment">// 因为很明白地显示了名称</span></span><br><span class="line">baz</span><br><span class="line">bar</span><br><span class="line">foo</span><br><span class="line">expr_test.html()</span><br></pre></td></tr></table></figure></p>
<p>通过查看调用栈的信息，我们可以很明了地知道foo调用了bar, bar又调用了baz（而foo本身有在expr_test.html文档的全局作用域内被调用），不过，还有一个比较爽地方，就是刚才说的Firebug为匿名表达式取名的功能：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Call stack</span></span><br><span class="line">baz</span><br><span class="line">bar() <span class="comment">//看到了么？</span></span><br><span class="line">foo</span><br><span class="line">expr_test.html()</span><br></pre></td></tr></table></figure></p>
<p>然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baz();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baz();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Call stack</span></span><br><span class="line">  baz</span><br><span class="line">  (?)() <span class="comment">// 这里可是问号哦</span></span><br><span class="line">  foo</span><br><span class="line">  expr_test.html()</span><br></pre></td></tr></table></figure>
<p>另外，当把函数赋值给多个变量的时候，也会出现令人郁闷的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> baz = bar;</span><br><span class="line">  bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;spoofed&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  foo();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Call stack:</span></span><br><span class="line">  bar()</span><br><span class="line">  foo</span><br><span class="line">  expr_test.html()</span><br></pre></td></tr></table></figure>
<p>这时候，调用栈显示的是foo调用了bar，但实际上并非如此，之所以有这种问题，是因为baz和另外一个包含alert(‘spoofed’)的函数做了引用交换所导致的。</p>
<p>归根结底，只有给函数表达式取个名字，才是最稳妥的办法，也就是使用<strong>命名函数表达式</strong>。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的2个函数的名字都是bar）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> baz();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> baz();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 又再次看到了清晰的调用栈信息了耶!</span></span><br><span class="line">baz</span><br><span class="line">bar</span><br><span class="line">foo</span><br><span class="line">expr_test.html()</span><br></pre></td></tr></table></figure></p>
<p>OK，又学了一招吧？不过在高兴之前，我们再看看不同寻常的JScript吧。</p>
<p>#JScript<br>这一部分讲的全都是<a href="http://baike.baidu.com/link?url=48ETrhbO1aXur5vwakiP1VZVKRaXJwc18zy8E87wtDaVUkSg2XfQFwTVFNDX42QcHaEMI_4KylkK4RdQkyCYra">JScript</a>而不是Javascript这两个真不是一种东西</p>
<blockquote>
<p>netscape开发了在Navigator中使用的LiveScript语言，后改名为JavaScript<br>Microsoft发行jscript用于internet explorer.<br>最初的jscript和javascript差异过大，web程序员不得不痛苦的为两种浏览器编写两种脚本。于是诞生了ECMAScript,是一种国际标准化的javascript版本。现在的主流浏览器都支持这种版本。<br>javascript是一个通用的名称，所有浏览器都认识，而jscript只有IE认识。<br>其他语言细节上的区别，不是一两下能说完的。编程时最好遵循ECMAscript标准。这样可以保证兼容性。<br>顺便说一下,javascript原来叫Livescript，后来Sun的java风头正盛的时候netscape就把名字改成javascript。</p>
</blockquote>
<p>个人感觉这一段基本上可以忽略了 但为了尊重作者我还是把它整理了一下。</p>
<h2 id="JScript的Bug"><a href="#JScript的Bug" class="headerlink" title="JScript的Bug"></a>JScript的Bug</h2><p>比较恶的是，IE的ECMAScript实现JScript严重混淆了命名函数表达式，搞得现很多人都出来反对命名函数表达式，而且即便是最新的一版（IE8中使用的5.8版）仍然存在下列问题。</p>
<p>下面我们就来看看IE在实现中究竟犯了那些错误，俗话说知已知彼，才能百战不殆。我们来看看如下几个例子：</p>
<p><strong>例1：函数表达式的标示符泄露到外部作用域</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> g; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但JScript明显是违反了这一规范，上面例子中的标示符g被解析成函数对象，这就乱了套了，很多难以发现的bug都是因为这个原因导致的。<br>==注：IE9貌似已经修复了这个问题==</p>
<p><strong>例2：将命名函数表达式同时当作函数声明和函数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> g; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是JScript实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了g。</p>
<p>这个例子引出了下一个例子。</p>
<p><strong>例3：命名函数表达式会创建两个截然不同的函数对象！</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">f === g; <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">f.expando = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">g.expando; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>看到这里，大家会觉得问题严重了，因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建2个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的g的同名属性来使用，那问题就大了，因为根本就不可能。</p>
<p>再来看一个稍微复杂的例子：</p>
<p><strong>例4：仅仅顺序解析函数声明而忽略条件语句块</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">g(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个bug查找就难多了，但导致bug的原因却非常简单。首先，g被当作函数声明解析，由于JScript中的函数声明不受条件代码块约束，所以在这个很恶的if分支中，g被当作另一个函数function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时f被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入“这个可恶if分支，因此f就会继续引用第一个函数function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了g，那么将会调用一个毫不相干的g函数对象。</p>
<p>你可能会文，将不同的对象和arguments.callee相比较时，有什么样的区别呢？我们来看看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="built_in">arguments</span>.callee == f,</span><br><span class="line">    <span class="built_in">arguments</span>.callee == g</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// [true, false]</span></span><br><span class="line">g(); <span class="comment">// [false, true]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，arguments.callee的引用一直是被调用的函数，实际上这也是好事，稍后会解释。</p>
<p>还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>按照代码的分析，我们原本是想创建一个全局属性f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p>
<p>了解了JScript这么变态以后，我们就要及时预防这些问题了，首先<strong>防范标识符泄漏带外部作用域</strong>，其次，应该永远<strong>不引用被用作函数名称的标识符</strong>；还记得前面例子中那个讨人厌的标识符g吗？——如果我们能够当g不存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过f或者arguments.callee来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把<strong>命名函数表达式声明期间错误创建的函数清理干净</strong>。</p>
<p>对于，上面最后一点，我们还得再解释一下。</p>
<h2 id="WebKit的displayName"><a href="#WebKit的displayName" class="headerlink" title="WebKit的displayName"></a>WebKit的displayName</h2><p><del>WebKit团队在这个问题采取了有点儿另类的策略。介于匿名和命名函数如此之差的表现力，WebKit引入了一个“特殊的”<code>displayName</code>属性（本质上是一个字符串），如果开发人员为函数的这个属性赋值，则该属性的值将在调试器或性能分析器中被显示在函数“名称”的位置上。<a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/">Francisco Tolmasky详细地解释了这个策略的原理和实现</a>。</del></p>
<h1 id="ECMAScript-5"><a href="#ECMAScript-5" class="headerlink" title="ECMAScript-5"></a>ECMAScript-5</h1><p>在ECMAScript-262第5版引入了<strong>严格模式（strict mode）</strong>。开启严格模式的实现会禁用语言中的那些不稳定、不可靠和不安全的特性。据说出于安全方面的考虑，<code>arguments.callee</code>属性将在严格模式下被“封杀”。因此，在处于严格模式时，访问<code>arguments.callee</code>会导致<code>TypeError</code>（参见ECMA-262第5版的10.6节）。而我之所以在此提到严格模式，是因为如果在基于第5版标准的实现中无法使用<code>arguments.callee</code>来执行递归操作，那么使用命名函数表达式的可能性就会大大增加。从这个意义上来说，理解命名函数表达式的语义及其bug也就显得更加重要了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此前，你可能会使用arguments.callee</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x - <span class="number">1</span>);</span><br><span class="line">  &#125;)(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 但在严格模式下，有可能就要使用命名函数表达式</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</span><br><span class="line">  &#125;)(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 要么就退一步，使用没有那么灵活的函数声明</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * factorial(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  factorial(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><strong><em>理查德· 康福德（Richard Cornford）</em></strong>，是他率先<a href="http://groups.google.com/group/comp.lang.javascript/msg/5b508b03b004bce8">解释了JScript中命名函数表达式所存在的bug</a>。理查德解释了我在这篇文章中提及的大多数bug，所以我强烈建议大家去看看他的解释。我还要感谢<strong><em>Yann-Erwan Perio</em></strong>和<strong><em>道格拉斯·克劳克佛德（Douglas Crockford）</em></strong>，他们早在2003年就在<a href="http://groups.google.com/group/comp.lang.javascript/msg/03d53d114d176323">comp.lang.javascript论坛中提及并讨论NFE问题了</a>。</p>
<p><strong><em>约翰-戴维·道尔顿（John-David Dalton）</em></strong>对“最终解决方案”提出了很好的建议。</p>
<p><strong><em>托比·兰吉</em></strong>的点子被我用在了“替代方案”中。</p>
<p><strong><em>盖瑞特·史密斯（Garrett Smith）</em></strong>和<strong><em>德米特里·苏斯尼科（Dmitry Soshnikov）</em></strong>对本文的多方面作出了补充和修正。</p>
<p>英文原文：<a href="http://kangax.github.com/nfe/">http://kangax.github.com/nfe/</a></p>
<p>参考译文：<a href="http://www.cn-cuckoo.com/main/wp-content/uploads/2009/12/named-function-expressions-demystified.html#jscript-memory-management">连接访问</a> (<span style="text-decoration: underline;">SpiderMonkey的怪癖</span>之后的章节参考该文)</p>
<h1 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h1><p>本文转自<a href="http://www.cnblogs.com/TomXu">TOM大叔</a>的<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a>本文有大量删减，<a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html">查看原文</a></p>
<blockquote>
<p>【深入理解JavaScript系列】文章，包括了原创，翻译，转载，整理等各类型文章，原文是TOM大叔的一个非常不错的专题，现将其重新整理发布。谢谢大叔。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean JavaScript:写出整洁的JavaScript代码</title>
    <url>/clean-code-javascript/</url>
    <content><![CDATA[<p><img src="/uploads/14839402166220.jpg" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/ryanmcdermott">作者</a>根据Robert C. Martin<a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><em>《代码整洁之道》</em></a>总结了适用于JavaScript的软件工程原则<a href="https://github.com/ryanmcdermott/clean-code-javascript">《Clean Code JavaScript》</a>。<br>本文是对其的翻译。原文地址:<a href="https://github.com/alivebao/clean-code-js">alivebao</a>。</p>
<span id="more"></span>
<p>不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。</p>
<p>软件工程已经发展了50多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。</p>
<p>最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><h3 id="使用有意义，可读性好的变量名"><a href="#使用有意义，可读性好的变量名" class="headerlink" title="使用有意义，可读性好的变量名"></a>使用有意义，可读性好的变量名</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yyyymmdstr = moment().format(<span class="string">&#x27;YYYY/MM/DD&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yearMonthDay = moment().format(<span class="string">&#x27;YYYY/MM/DD&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ES6的const定义常量"><a href="#使用ES6的const定义常量" class="headerlink" title="使用ES6的const定义常量"></a>使用ES6的const定义常量</h3><p>反例中使用”var”定义的”常量”是可变的。</p>
<p>在声明一个常量时，该常量在整个程序中都应该是不可变的。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FIRST_US_PRESIDENT = <span class="string">&quot;George Washington&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FIRST_US_PRESIDENT = <span class="string">&quot;George Washington&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="对功能类似的变量名采用统一的命名风格"><a href="#对功能类似的变量名采用统一的命名风格" class="headerlink" title="对功能类似的变量名采用统一的命名风格"></a>对功能类似的变量名采用统一的命名风格</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getUserInfo();</span><br><span class="line">getClientData();</span><br><span class="line">getCustomerRecord();</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getUser();</span><br></pre></td></tr></table></figure></p>
<h3 id="使用易于检索名称"><a href="#使用易于检索名称" class="headerlink" title="使用易于检索名称"></a>使用易于检索名称</h3><p>我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。<br>让你的变量名易于检索。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 525600 是什么?</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">525600</span>; i++) &#123;</span><br><span class="line">  runCronJob();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare them as capitalized `var` globals.</span></span><br><span class="line"><span class="keyword">var</span> MINUTES_IN_A_YEAR = <span class="number">525600</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; MINUTES_IN_A_YEAR; i++) &#123;</span><br><span class="line">  runCronJob();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用说明变量-即有意义的变量名"><a href="#使用说明变量-即有意义的变量名" class="headerlink" title="使用说明变量(即有意义的变量名)"></a>使用说明变量(即有意义的变量名)</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</span><br><span class="line">saveCityState(cityStateRegex.match(cityStateRegex)[<span class="number">1</span>], cityStateRegex.match(cityStateRegex)[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> match = cityStateRegex.match(cityStateRegex)</span><br><span class="line"><span class="keyword">const</span> city = match[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> state = match[<span class="number">2</span>];</span><br><span class="line">saveCityState(city, state);</span><br></pre></td></tr></table></figure></p>
<h3 id="不要绕太多的弯子"><a href="#不要绕太多的弯子" class="headerlink" title="不要绕太多的弯子"></a>不要绕太多的弯子</h3><p>显式优于隐式。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locations = [<span class="string">&#x27;Austin&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>];</span><br><span class="line">locations.forEach(<span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</span><br><span class="line">  doStuff();</span><br><span class="line">  doSomeOtherStuff();</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// l是什么？</span></span><br><span class="line">  dispatch(l);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locations = [<span class="string">&#x27;Austin&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>];</span><br><span class="line">locations.forEach(<span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">  doStuff();</span><br><span class="line">  doSomeOtherStuff();</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  dispatch(location);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="避免重复的描述"><a href="#避免重复的描述" class="headerlink" title="避免重复的描述"></a>避免重复的描述</h3><p>当类/对象名已经有意义时，对其变量进行命名不需要再次重复。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Car = &#123;</span><br><span class="line">  carMake: <span class="string">&#x27;Honda&#x27;</span>,</span><br><span class="line">  carModel: <span class="string">&#x27;Accord&#x27;</span>,</span><br><span class="line">  carColor: <span class="string">&#x27;Blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintCar</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  car.carColor = <span class="string">&#x27;Red&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Car = &#123;</span><br><span class="line">  make: <span class="string">&#x27;Honda&#x27;</span>,</span><br><span class="line">  model: <span class="string">&#x27;Accord&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;Blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintCar</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  car.color = <span class="string">&#x27;Red&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免无意义的条件判断"><a href="#避免无意义的条件判断" class="headerlink" title="避免无意义的条件判断"></a>避免无意义的条件判断</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> breweryName;</span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    breweryName = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    breweryName = <span class="string">&#x27;Hipster Brew Co.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> breweryName = name || <span class="string">&#x27;Hipster Brew Co.&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="函数参数-理想情况下应不超过2个"><a href="#函数参数-理想情况下应不超过2个" class="headerlink" title="函数参数 (理想情况下应不超过2个)"></a>函数参数 (理想情况下应不超过2个)</h3><p>限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。</p>
<p>应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。</p>
<p>JS定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">title, body, buttonText, cancellable</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  title: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">  body: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">  buttonText: <span class="string">&#x27;Baz&#x27;</span>,</span><br><span class="line">  cancellable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">menuConfig</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="函数功能的单一性"><a href="#函数功能的单一性" class="headerlink" title="函数功能的单一性"></a>函数功能的单一性</h3><p>这是软件功能中最重要的原则之一。</p>
<p>功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params">clients</span>) </span>&#123;</span><br><span class="line">  clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> clientRecord = database.lookup(client);</span><br><span class="line">    <span class="keyword">if</span> (clientRecord.isActive()) &#123;</span><br><span class="line">      email(client);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params">clients</span>) </span>&#123;</span><br><span class="line">  clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    emailClientIfNeeded(client);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClientIfNeeded</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isClientActive(client)) &#123;</span><br><span class="line">    email(client);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClientActive</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clientRecord = database.lookup(client);</span><br><span class="line">  <span class="keyword">return</span> clientRecord.isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数名应明确表明其功能"><a href="#函数名应明确表明其功能" class="headerlink" title="函数名应明确表明其功能"></a>函数名应明确表明其功能</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateAdd</span>(<span class="params">date, month</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很难理解dateAdd(date, 1)是什么意思</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateAddMonth</span>(<span class="params">date, month</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">dateAddMonth(date, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="函数应该只做一层抽象"><a href="#函数应该只做一层抽象" class="headerlink" title="函数应该只做一层抽象"></a>函数应该只做一层抽象</h3><p>当函数的需要的抽象多余一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBetterJSAlternative</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> REGEXES = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> statements = code.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tokens;</span><br><span class="line">  REGEXES.forEach(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</span><br><span class="line">    statements.forEach(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ast;</span><br><span class="line">  tokens.forEach(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ast.forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> REGEXES = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> statements = code.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tokens;</span><br><span class="line">  REGEXES.forEach(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</span><br><span class="line">    statements.forEach(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lexer</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ast;</span><br><span class="line">  tokens.forEach(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBetterJSAlternative</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = tokenize(code);</span><br><span class="line">  <span class="keyword">let</span> ast = lexer(tokens);</span><br><span class="line">  ast.forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="移除重复的代码"><a href="#移除重复的代码" class="headerlink" title="移除重复的代码"></a>移除重复的代码</h3><p>永远、永远、永远不要在任何循环下有重复的代码。</p>
<p>这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDeveloperList</span>(<span class="params">developers</span>) </span>&#123;</span><br><span class="line">  developers.forEach(<span class="function"><span class="params">developers</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = developer.calculateExpectedSalary();</span><br><span class="line">    <span class="keyword">var</span> experience = developer.getExperience();</span><br><span class="line">    <span class="keyword">var</span> githubLink = developer.getGithubLink();</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      expectedSalary: expectedSalary,</span><br><span class="line">      experience: experience,</span><br><span class="line">      githubLink: githubLink</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showManagerList</span>(<span class="params">managers</span>) </span>&#123;</span><br><span class="line">  managers.forEach(<span class="function"><span class="params">manager</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = manager.calculateExpectedSalary();</span><br><span class="line">    <span class="keyword">var</span> experience = manager.getExperience();</span><br><span class="line">    <span class="keyword">var</span> portfolio = manager.getMBAProjects();</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      expectedSalary: expectedSalary,</span><br><span class="line">      experience: experience,</span><br><span class="line">      portfolio: portfolio</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showList</span>(<span class="params">employees</span>) </span>&#123;</span><br><span class="line">  employees.forEach(<span class="function"><span class="params">employee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = employee.calculateExpectedSalary();</span><br><span class="line">    <span class="keyword">var</span> experience = employee.getExperience();</span><br><span class="line">    <span class="keyword">var</span> portfolio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (employee.type === <span class="string">&#x27;manager&#x27;</span>) &#123;</span><br><span class="line">      portfolio = employee.getMBAProjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      portfolio = employee.getGithubLink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      expectedSalary: expectedSalary,</span><br><span class="line">      experience: experience,</span><br><span class="line">      portfolio: portfolio</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="采用默认参数精简代码"><a href="#采用默认参数精简代码" class="headerlink" title="采用默认参数精简代码"></a>采用默认参数精简代码</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject, body</span>) </span>&#123;</span><br><span class="line">  subject = subject || <span class="string">&#x27;No Subject&#x27;</span>;</span><br><span class="line">  body = body || <span class="string">&#x27;No text&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject = <span class="string">&#x27;No subject&#x27;</span>, body = <span class="string">&#x27;No text&#x27;</span></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="使用Object-assign设置默认对象"><a href="#使用Object-assign设置默认对象" class="headerlink" title="使用Object.assign设置默认对象"></a>使用Object.assign设置默认对象</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  title: <span class="literal">null</span>,</span><br><span class="line">  body: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">  buttonText: <span class="literal">null</span>,</span><br><span class="line">  cancellable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.title = config.title || <span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">  config.body = config.body || <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  config.buttonText = config.buttonText || <span class="string">&#x27;Baz&#x27;</span></span><br><span class="line">  config.cancellable = config.cancellable === <span class="literal">undefined</span> ? config.cancellable : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMenu(menuConfig);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  title: <span class="string">&#x27;Order&#x27;</span>,</span><br><span class="line">  <span class="comment">// User did not include &#x27;body&#x27; key</span></span><br><span class="line">  buttonText: <span class="string">&#x27;Send&#x27;</span>,</span><br><span class="line">  cancellable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    title: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    body: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    buttonText: <span class="string">&#x27;Baz&#x27;</span>,</span><br><span class="line">    cancellable: <span class="literal">true</span></span><br><span class="line">  &#125;, config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// config now equals: &#123;title: &quot;Foo&quot;, body: &quot;Bar&quot;, buttonText: &quot;Baz&quot;, cancellable: true&#125;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMenu(menuConfig);</span><br></pre></td></tr></table></figure></p>
<h3 id="不要使用标记-Flag-作为函数参数"><a href="#不要使用标记-Flag-作为函数参数" class="headerlink" title="不要使用标记(Flag)作为函数参数"></a>不要使用标记(Flag)作为函数参数</h3><p>这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFile</span>(<span class="params">name, temp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">    fs.create(<span class="string">&#x27;./temp/&#x27;</span> + name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.create(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTempFile</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  fs.create(<span class="string">&#x27;./temp/&#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFile</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  fs.create(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。</p>
<p>程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个service完成这一需求。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variable referenced by following function.</span></span><br><span class="line"><span class="comment">// If we had another function that used this name, now it&#x27;d be an array and it could break it.</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryan McDermott&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitIntoFirstAndLastName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = name.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">splitIntoFirstAndLastName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitIntoFirstAndLastName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryan McDermott&#x27;</span></span><br><span class="line"><span class="keyword">var</span> newName = splitIntoFirstAndLastName(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// &#x27;Ryan McDermott&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(newName); <span class="comment">// [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不要写全局函数"><a href="#不要写全局函数" class="headerlink" title="不要写全局函数"></a>不要写全局函数</h3><p>在JS中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的API的用户在实际环境中得到一个exception前对这一情况是一无所知的。</p>
<p>想象以下例子：如果你想扩展JS中的Array，为其添加一个<code>diff</code>函数显示两个数组间的差异，此时应如何去做？你可以将diff写入<code>Array.prototype</code>，但这么做会和其他有类似需求的库造成冲突。如果另一个库对diff的需求为比较一个数组中收尾元素间的差异呢？</p>
<p>使用ES6中的class对全局的Array做简单的扩展显然是一个更棒的选择。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.diff = <span class="function"><span class="keyword">function</span>(<span class="params">comparisonArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [];</span><br><span class="line">  <span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</span><br><span class="line">    hash[i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hash[i]) &#123;</span><br><span class="line">      values.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">diff</span>(<span class="params">comparisonArray</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> values = [];</span><br><span class="line">    <span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</span><br><span class="line">      hash[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hash[i]) &#123;</span><br><span class="line">        values.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="采用函数式编程"><a href="#采用函数式编程" class="headerlink" title="采用函数式编程"></a>采用函数式编程</h3><p>函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> programmerOutput = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Uncle Bobby&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Suzie Q&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">1500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jimmy Gosling&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">150</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Gracie Hopper&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalOutput = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; programmerOutput.length; i++) &#123;</span><br><span class="line">  totalOutput += programmerOutput[i].linesOfCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> programmerOutput = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Uncle Bobby&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Suzie Q&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">1500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jimmy Gosling&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">150</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">&#x27;Gracie Hopper&#x27;</span>,</span><br><span class="line">    linesOfCode: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalOutput = programmerOutput</span><br><span class="line">  .map(<span class="function">(<span class="params">programmer</span>) =&gt;</span> programmer.linesOfCode)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">acc, linesOfCode</span>) =&gt;</span> acc + linesOfCode, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="封装判断条件"><a href="#封装判断条件" class="headerlink" title="封装判断条件"></a>封装判断条件</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fsm.state === <span class="string">&#x27;fetching&#x27;</span> &amp;&amp; isEmpty(listNode)) &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldShowSpinner</span>(<span class="params">fsm, listNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fsm.state === <span class="string">&#x27;fetching&#x27;</span> &amp;&amp; isEmpty(listNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免“否定情况”的判断"><a href="#避免“否定情况”的判断" class="headerlink" title="避免“否定情况”的判断"></a>避免“否定情况”的判断</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDOMNodeNotPresent</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isDOMNodeNotPresent(node)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDOMNodePresent</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDOMNodePresent(node)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免条件判断"><a href="#避免条件判断" class="headerlink" title="避免条件判断"></a>避免条件判断</h3><p>这看起来似乎不太可能。</p>
<p>大多人听到这的第一反应是：“怎么可能不用if完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。</p>
<p>第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;777&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> getMaxAltitude() - getPassengerCount();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Air Force One&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> getMaxAltitude();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Cessna&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> getMaxAltitude() - getFuelExpenditure();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boeing777</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxAltitude() - getPassengerCount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirForceOne</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxAltitude();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cessna</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxAltitude() - getFuelExpenditure();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免类型判断-part-1"><a href="#避免类型判断-part-1" class="headerlink" title="避免类型判断(part 1)"></a>避免类型判断(part 1)</h3><p>JS是弱类型语言，这意味着函数可接受任意类型的参数。</p>
<p>有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Bicycle) &#123;</span><br><span class="line">    vehicle.peddle(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Car) &#123;</span><br><span class="line">    vehicle.drive(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  vehicle.move(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免类型判断-part-2"><a href="#避免类型判断-part-2" class="headerlink" title="避免类型判断(part 2)"></a>避免类型判断(part 2)</h3><p>如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用TypeScript。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val1 == <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">&quot;number&quot;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> val1 == <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val1 + val2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Must be of type String or Number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免过度优化"><a href="#避免过度优化" class="headerlink" title="避免过度优化"></a>避免过度优化</h3><p>现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。</p>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers">这里可以找到许多真正需要优化的地方</a></p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里使用变量len是因为在老式浏览器中，</span></span><br><span class="line"><span class="comment">// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，</span></span><br><span class="line"><span class="comment">// 而在现代浏览器中会自动完成优化，这一行为是没有必要的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除无效的代码"><a href="#删除无效的代码" class="headerlink" title="删除无效的代码"></a>删除无效的代码</h3><p>不再被调用的代码应及时删除。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oldRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = newRequestModule;</span><br><span class="line">inventoryTracker(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = newRequestModule;</span><br><span class="line">inventoryTracker(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a><strong>对象和数据结构</strong></h2><h3 id="使用getters和setters"><a href="#使用getters和setters" class="headerlink" title="使用getters和setters"></a>使用getters和setters</h3><p>JS没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似<code>public</code>和<code>private</code>的关键词。</p>
<p>然而，使用getters和setters获取对象的数据远比直接使用点操作符具有优势。为什么呢？</p>
<ol>
<li>当需要对获取的对象属性执行额外操作时。</li>
<li>执行<code>set</code>时可以增加规则对要变量的合法性进行判断。</li>
<li>封装了内部逻辑。</li>
<li>在存取时可以方便的增加日志和错误处理。</li>
<li>继承该类时可以重载默认行为。</li>
<li>从服务器获取数据时可以进行懒加载。</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	   <span class="built_in">this</span>.balance = <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buy shoes...</span></span><br><span class="line">bankAccount.balance = bankAccount.balance - <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	   <span class="built_in">this</span>.balance = <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It doesn&#x27;t have to be prefixed with `get` or `set` to be a getter/setter</span></span><br><span class="line">  <span class="function"><span class="title">withdraw</span>(<span class="params">amount</span>)</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> (verifyAmountCanBeDeducted(amount)) &#123;</span><br><span class="line">  	  <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> BankAccount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buy shoes...</span></span><br><span class="line">bankAccount.withdraw(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="让对象拥有私有成员"><a href="#让对象拥有私有成员" class="headerlink" title="让对象拥有私有成员"></a>让对象拥有私有成员</h3><p>可以通过闭包完成</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Employee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Employee name: &#x27;</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Employee name: &#x27;</span> + employee.getName()); <span class="comment">// Employee name: undefined</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Employee = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Employee;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Employee name: &#x27;</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Employee name: &#x27;</span> + employee.getName()); <span class="comment">// Employee name: John Doe</span></span><br></pre></td></tr></table></figure></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h2><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 (SRP)"></a>单一职责原则 (SRP)</h3><p>如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。</p>
<p>将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。</p>
<p>最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSettings</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">changeSettings</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.verifyCredentials(user)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verifyCredentials</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAuth</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verifyCredentials</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSettings</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">    <span class="built_in">this</span>.auth = <span class="keyword">new</span> UserAuth(user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">changeSettings</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.auth.verifyCredentials()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="开-闭原则-OCP"><a href="#开-闭原则-OCP" class="headerlink" title="开/闭原则 (OCP)"></a>开/闭原则 (OCP)</h3><p>“代码实体(类，模块，函数等)应该易于扩展，难于修改。”</p>
<p>这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开js文件源码手动对其进行修改。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// What if we wanted another HTTP Method, like DELETE? We would have to</span></span><br><span class="line">    <span class="comment">// open this file up and modify this and put it in manually.</span></span><br><span class="line">    <span class="built_in">this</span>.HTTP_METHODS = [<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.HTTP_METHODS = [<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addHTTPMethod</span>(<span class="params">method</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.HTTP_METHODS.push(method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="利斯科夫替代原则-LSP"><a href="#利斯科夫替代原则-LSP" class="headerlink" title="利斯科夫替代原则 (LSP)"></a>利斯科夫替代原则 (LSP)</h3><p>“子类对象应该能够替换其超类对象被使用”。</p>
<p>也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">area</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setWidth</span>(<span class="params">width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setHeight</span>(<span class="params">height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setWidth</span>(<span class="params">width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">    <span class="built_in">this</span>.height = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setHeight</span>(<span class="params">height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = height;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeRectangles</span>(<span class="params">rectangles</span>) </span>&#123;</span><br><span class="line">  rectangles.forEach(<span class="function">(<span class="params">rectangle</span>) =&gt;</span> &#123;</span><br><span class="line">    rectangle.setWidth(<span class="number">4</span>);</span><br><span class="line">    rectangle.setHeight(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> area = rectangle.getArea(); <span class="comment">// BAD: Will return 25 for Square. Should be 20.</span></span><br><span class="line">    rectangle.render(area);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rectangles = [<span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Square()];</span><br><span class="line">renderLargeRectangles(rectangles);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">area</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setWidth</span>(<span class="params">width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setHeight</span>(<span class="params">height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setLength</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeShapes</span>(<span class="params">shapes</span>) </span>&#123;</span><br><span class="line">  shapes.forEach(<span class="function">(<span class="params">shape</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.constructor.name) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Square&#x27;</span>:</span><br><span class="line">        shape.setLength(<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Rectangle&#x27;</span>:</span><br><span class="line">        shape.setWidth(<span class="number">4</span>);</span><br><span class="line">        shape.setHeight(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> area = shape.getArea();</span><br><span class="line">    shape.render(area);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapes = [<span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Square()];</span><br><span class="line">renderLargeShapes(shapes);</span><br></pre></td></tr></table></figure></p>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。”</p>
<p>在JS中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.settings = settings;</span><br><span class="line">    <span class="built_in">this</span>.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootNode = <span class="built_in">this</span>.settings.rootNode;</span><br><span class="line">    <span class="built_in">this</span>.animationModule.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">traverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</span><br><span class="line">  rootNode: <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  animationModule: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// Most of the time, we won&#x27;t need to animate when traversing.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.settings = settings;</span><br><span class="line">    <span class="built_in">this</span>.options = settings.options;</span><br><span class="line">    <span class="built_in">this</span>.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootNode = <span class="built_in">this</span>.settings.rootNode;</span><br><span class="line">    <span class="built_in">this</span>.setupOptions();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setupOptions</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.options.animationModule) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">traverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</span><br><span class="line">  rootNode: <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  options: &#123;</span><br><span class="line">    animationModule: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>该原则有两个核心点:  </p>
<ol>
<li>高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。</li>
<li>抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">items</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BAD: We have created a dependency on a specific request implementation.</span></span><br><span class="line">    <span class="comment">// We should just have requestItems depend on a request method: `request`</span></span><br><span class="line">    <span class="built_in">this</span>.requester = <span class="keyword">new</span> InventoryRequester();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.requester.requestItem(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>]);</span><br><span class="line">inventoryTracker.requestItems();</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">items, requester</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = items;</span><br><span class="line">    <span class="built_in">this</span>.requester = requester;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.requester.requestItem(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterV1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterV2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;WS&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By constructing our dependencies externally and injecting them, we can easily</span></span><br><span class="line"><span class="comment">// substitute our request module for a fancy new one that uses WebSockets.</span></span><br><span class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>], <span class="keyword">new</span> InventoryRequesterV2());</span><br><span class="line">inventoryTracker.requestItems();</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ES6的classes而不是ES5的Function"><a href="#使用ES6的classes而不是ES5的Function" class="headerlink" title="使用ES6的classes而不是ES5的Function"></a>使用ES6的classes而不是ES5的Function</h3><p>典型的ES5的类(function)在继承、构造和方法定义方面可读性较差。</p>
<p>当需要继承时，优先选用classes。</p>
<p>但是，当在需要更大更复杂的对象时，最好优先选择更小的function而非classes。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Animal)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Instantiate Animal with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Mammal)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Instantiate Mammal with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal.call(<span class="built_in">this</span>, age);</span><br><span class="line">    <span class="built_in">this</span>.furColor = furColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mammal.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Mammal.prototype.constructor = Mammal;</span><br><span class="line">Mammal.prototype.liveBirth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor, languageSpoken</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Human)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Instantiate Human with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mammal.call(<span class="built_in">this</span>, age, furColor);</span><br><span class="line">    <span class="built_in">this</span>.languageSpoken = languageSpoken;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Human.prototype = <span class="built_in">Object</span>.create(Mammal.prototype);</span><br><span class="line">Human.prototype.constructor = Human;</span><br><span class="line">Human.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mammal</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age, furColor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age);</span><br><span class="line">        <span class="built_in">this</span>.furColor = furColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">liveBirth</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Mammal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age, furColor, languageSpoken</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, furColor);</span><br><span class="line">        <span class="built_in">this</span>.languageSpoken = languageSpoken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h3><p>这里我们的理解与《代码整洁之道》的建议有些不同。</p>
<p>有争论说方法链不够干净且违反了<a href="https://en.wikipedia.org/wiki/Law_of_Demeter">德米特法则</a>,也许这是对的，但这种方法在JS及许多库(如JQuery)中显得非常实用。</p>
<p>因此，我认为在JS中使用方法链是非常合适的。在class的函数中返回this，能够方便的将类需要执行的多个方法链接起来。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = <span class="string">&#x27;Honda&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.model = <span class="string">&#x27;Accord&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setMake</span>(<span class="params">make</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setModel</span>(<span class="params">model</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.make, <span class="built_in">this</span>.model, <span class="built_in">this</span>.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setColor(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">car.setMake(<span class="string">&#x27;Ford&#x27;</span>);</span><br><span class="line">car.setModel(<span class="string">&#x27;F-150&#x27;</span>)</span><br><span class="line">car.save();</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = <span class="string">&#x27;Honda&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.model = <span class="string">&#x27;Accord&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setMake</span>(<span class="params">make</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setModel</span>(<span class="params">model</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.make, <span class="built_in">this</span>.model, <span class="built_in">this</span>.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car()</span><br><span class="line">  .setColor(<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">  .setMake(<span class="string">&#x27;Ford&#x27;</span>)</span><br><span class="line">  .setModel(<span class="string">&#x27;F-150&#x27;</span>)</span><br><span class="line">  .save();</span><br></pre></td></tr></table></figure></p>
<h3 id="优先使用组合模式而非继承"><a href="#优先使用组合模式而非继承" class="headerlink" title="优先使用组合模式而非继承"></a>优先使用组合模式而非继承</h3><p>在著名的<a href="https://en.wikipedia.org/wiki/Design_Patterns">设计模式</a>一书中提到，应多使用组合模式而非继承。</p>
<p>这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。</p>
<p>那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点：</p>
<ol>
<li>继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节)</li>
<li>可以复用基类的代码(“Human”可以看成是”All animal”的一种)</li>
<li>希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量)</li>
</ol>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, email</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.email = email;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad because Employees &quot;have&quot; tax data. EmployeeTaxData is not a type of Employee</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, email</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.email = email;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setTaxData</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.taxData = <span class="keyword">new</span> EmployeeTaxData(ssn, salary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p><a href="http://gotwarlost.github.io/istanbul/">一些好的覆盖工具</a>.</p>
<p><a href="http://jstherightway.org/#testing-tools">一些好的JS测试框架</a></p>
<h3 id="单一的测试每个概念"><a href="#单一的测试每个概念" class="headerlink" title="单一的测试每个概念"></a>单一的测试每个概念</h3><p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&#x27;handles date boundaries&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date;</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">30</span>);</span><br><span class="line">    date.shouldEqual(<span class="string">&#x27;1/31/2015&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">&#x27;handles 30-day months&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">30</span>);</span><br><span class="line">    date.shouldEqual(<span class="string">&#x27;1/31/2015&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;handles leap year&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;handles non-leap year&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><h3 id="用Promises替代回调"><a href="#用Promises替代回调" class="headerlink" title="用Promises替代回调"></a>用Promises替代回调</h3><p>回调不够整洁并会造成大量的嵌套。ES6内嵌了Promises，使用它吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>).get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).writeFile(<span class="string">&#x27;article.html&#x27;</span>, response.body, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>).get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>).writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="Async-Await是较Promises更好的选择"><a href="#Async-Await是较Promises更好的选择" class="headerlink" title="Async/Await是较Promises更好的选择"></a>Async/Await是较Promises更好的选择</h3><p>Promises是较回调而言更好的一种选择，但ES7中的async和await更胜过Promises。</p>
<p>在能使用ES7特性的情况下可以尽量使用他们替代Promises。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>).get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>).writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getCleanCodeArticle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> request.get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> fileHandle = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> fileHandle.writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h2><p>错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。</p>
<h3 id="别忘了捕获错误"><a href="#别忘了捕获错误" class="headerlink" title="别忘了捕获错误"></a>别忘了捕获错误</h3><p>对捕获的错误不做任何处理是没有意义的。</p>
<p>代码中<code>try/catch</code>的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  functionThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  functionThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// One option (more noisy than console.log):</span></span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  notifyUserOfError(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  reportErrorToService(error);</span><br><span class="line">  <span class="comment">// OR do all three!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="不要忽略被拒绝的promises"><a href="#不要忽略被拒绝的promises" class="headerlink" title="不要忽略被拒绝的promises"></a>不要忽略被拒绝的promises</h3><p>理由同<code>try/catch</code>.</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getdata()</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  functionThatMightThrow(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getdata()</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  functionThatMightThrow(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// One option (more noisy than console.log):</span></span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  notifyUserOfError(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  reportErrorToService(error);</span><br><span class="line">  <span class="comment">// OR do all three!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a><strong>格式化</strong></h2><p>格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在<a href="http://standardjs.com/rules.html">这里</a>完成格式的自动化。</p>
<h3 id="大小写一致"><a href="#大小写一致" class="headerlink" title="大小写一致"></a>大小写一致</h3><p>JS是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。</p>
<p>这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DAYS_IN_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> daysInMonth = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> songs = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> Artists = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restore_database</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DAYS_IN_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> DAYS_IN_MONTH = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> songs = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> artists = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restoreDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用函数的函数和被调函数应放在较近的位置"><a href="#调用函数的函数和被调函数应放在较近的位置" class="headerlink" title="调用函数的函数和被调函数应放在较近的位置"></a>调用函数的函数和被调函数应放在较近的位置</h3><p>当函数间存在相互调用的情况时，应将两者置于较近的位置。</p>
<p>理想情况下，应将调用其他函数的函数写在被调用函数的上方。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">employee</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.employee = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupPeers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupMananger</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getPeerReviews</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> peers = <span class="built_in">this</span>.lookupPeers();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">perfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      getPeerReviews();</span><br><span class="line">      getManagerReview();</span><br><span class="line">      getSelfReview();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getManagerReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> manager = <span class="built_in">this</span>.lookupManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getSelfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> PerformanceReview(user);</span><br><span class="line">review.perfReview();</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">employee</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.employee = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">perfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      getPeerReviews();</span><br><span class="line">      getManagerReview();</span><br><span class="line">      getSelfReview();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getPeerReviews</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> peers = <span class="built_in">this</span>.lookupPeers();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupPeers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getManagerReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> manager = <span class="built_in">this</span>.lookupManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupMananger</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getSelfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> PerformanceReview(employee);</span><br><span class="line">review.perfReview();</span><br></pre></td></tr></table></figure></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><h3 id="只对存在一定业务逻辑复制性的代码进行注释"><a href="#只对存在一定业务逻辑复制性的代码进行注释" class="headerlink" title="只对存在一定业务逻辑复制性的代码进行注释"></a>只对存在一定业务逻辑复制性的代码进行注释</h3><p>注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The hash</span></span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Length of string</span></span><br><span class="line">  <span class="keyword">var</span> length = data.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through every character in data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// Get character code.</span></span><br><span class="line">    <span class="keyword">var</span> char = data.charCodeAt(i);</span><br><span class="line">    <span class="comment">// Make the hash</span></span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash = hash &amp; hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> length = data.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> char = data.charCodeAt(i);</span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash = hash &amp; hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="不要在代码库中遗留被注释掉的代码"><a href="#不要在代码库中遗留被注释掉的代码" class="headerlink" title="不要在代码库中遗留被注释掉的代码"></a>不要在代码库中遗留被注释掉的代码</h3><p>版本控制的存在是有原因的。让旧代码存在于你的history里吧。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doStuff();</span><br><span class="line"><span class="comment">// doOtherStuff();</span></span><br><span class="line"><span class="comment">// doSomeMoreStuff();</span></span><br><span class="line"><span class="comment">// doSoMuchStuff();</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doStuff();</span><br></pre></td></tr></table></figure></p>
<h3 id="不需要版本更新类型注释"><a href="#不需要版本更新类型注释" class="headerlink" title="不需要版本更新类型注释"></a>不需要版本更新类型注释</h3><p>记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。</p>
<p>需要时可以使用<code>git log</code>获取历史版本。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2016-12-20: Removed monads, didn&#x27;t understand them (RM)</span></span><br><span class="line"><span class="comment"> * 2016-10-01: Improved using special monads (JP)</span></span><br><span class="line"><span class="comment"> * 2016-02-03: Removed type-checking (LI)</span></span><br><span class="line"><span class="comment"> * 2015-03-14: Added combine with type-checking (JR)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免位置标记"><a href="#避免位置标记" class="headerlink" title="避免位置标记"></a>避免位置标记</h3><p>这些东西通常只能代码麻烦，采用适当的缩进就可以了。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Scope Model Instantiation</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> $scope.model = &#123;</span><br><span class="line">  menu: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  nav: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Action setup</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> $scope.model = &#123;</span><br><span class="line">  menu: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  nav: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免在源文件中写入法律评论"><a href="#避免在源文件中写入法律评论" class="headerlink" title="避免在源文件中写入法律评论"></a>避免在源文件中写入法律评论</h3><p>将你的<code>LICENSE</code>文件置于源码目录树的根目录。</p>
<p><strong>反例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The MIT License (MIT)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Copyright (c) 2016 Ryan McDermott</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment">of this software and associated documentation files (the &quot;Software&quot;), to deal</span></span><br><span class="line"><span class="comment">in the Software without restriction, including without limitation the rights</span></span><br><span class="line"><span class="comment">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></span><br><span class="line"><span class="comment">copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment">furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The above copyright notice and this permission notice shall be included in all</span></span><br><span class="line"><span class="comment">copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></span><br><span class="line"><span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span></span><br><span class="line"><span class="comment">SOFTWARE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正例</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>编写高质量JavaScript代码的基本要点</title>
    <url>/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FJavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<p>#前言<br>才华横溢的<a href="http://www.phpied.com/">Stoyan Stefanov</a>，在他写的由<a href="http://oreilly.com/">O’Reilly</a>初版的新书<a href="http://amzn.to/93szK7">《JavaScript Patterns》</a>(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。<br>此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。</p>
<span id="more"></span>
<h1 id="书写可维护的代码"><a href="#书写可维护的代码" class="headerlink" title="书写可维护的代码"></a>书写可维护的代码</h1><p>软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p>
<ul>
<li>花时间学习和理解这个问题</li>
<li>化时间是了解应该解决的问题代码</li>
</ul>
<p>还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。<br>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。<br>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p>
<ul>
<li>bug是暴露的</li>
<li>新功能被添加到应用程序</li>
<li>程序在新的环境下工作（例如，市场上出现新想浏览器）</li>
<li>代码改变用途</li>
<li>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</li>
</ul>
<p>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。<br>可维护的代码意味着：</p>
<ul>
<li>可读的</li>
<li>一致的</li>
<li>可预测的</li>
<li>看上去就像是同一个人写的</li>
<li>已记录</li>
</ul>
<h1 id="最小全局变量"><a href="#最小全局变量" class="headerlink" title="最小全局变量"></a>最小全局变量</h1><p>JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。<br>每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myglobal = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 不推荐写法</span></span><br><span class="line"><span class="built_in">console</span>.log(myglobal); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myglobal); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">&quot;myglobal&quot;</span>]); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.myglobal); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h2><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。<br>web页面包含不是该页面开发者所写的代码也是比较常见的，例如：</p>
<ul>
<li>第三方的JavaScript库</li>
<li>广告方的脚本代码</li>
<li>第三方用户跟踪和分析脚本代码</li>
<li>不同类型的小组件，标志和按钮</li>
</ul>
<p>比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！<br>因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。<br>由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 不推荐写法: 隐式全局变量</span></span><br><span class="line">   result = x + y;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此段代码中的<code>result</code>没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。<br>经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> result = x + y;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，<code>a</code>是本地变量,但是<code>b</code>却是全局变量，这可能不是你希望发生的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例，勿使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = b = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式<code>b = 0</code>，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (b = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a, b;</span><br><span class="line">   <span class="comment">// ... a = b = 0; // 两个均局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。</p>
</blockquote>
<h2 id="忘记var的副作用"><a href="#忘记var的副作用" class="headerlink" title="忘记var的副作用"></a>忘记var的副作用</h2><p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过<code>delete</code>操作符让变量未定义的能力。</p>
<ul>
<li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li>
<li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li>
</ul>
<p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过<code>delete</code>操作符删除的，而变量是不能的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义三个全局变量</span></span><br><span class="line"><span class="keyword">var</span> global_var = <span class="number">1</span>;</span><br><span class="line">global_novar = <span class="number">2</span>; <span class="comment">// 反面教材</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   global_fromfunc = <span class="number">3</span>; <span class="comment">// 反面教材</span></span><br><span class="line">&#125;());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 试图删除</span></span><br><span class="line"><span class="keyword">delete</span> global_var; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> global_novar; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> global_fromfunc; <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试该删除</span></span><br><span class="line"><span class="keyword">typeof</span> global_var; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> global_novar; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> global_fromfunc; <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。</p>
<h2 id="访问全局对象"><a href="#访问全局对象" class="headerlink" title="访问全局对象"></a>访问全局对象</h2><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">global</span> = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过<code>new</code>构造），<code>this</code>总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p>
<h2 id="单var形式"><a href="#单var形式" class="headerlink" title="单var形式"></a>单var形式</h2><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量，因此较少了全局变量==//zxx:此处我自己是有点晕乎的…==</li>
<li>少代码（类型啊传值啊单线完成）</li>
</ul>
<p>单var形式长得就像下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">       b = <span class="number">2</span>,</span><br><span class="line">       sum = a + b,</span><br><span class="line">       myobject = &#123;&#125;,</span><br><span class="line">       i,</span><br><span class="line">       j;</span><br><span class="line">   <span class="comment">// function body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是<code>undefined</code>）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。</p>
<p>你也可以在声明的时候做一些实际的工作，例如前面代码中的<code>sum = a + b</code>这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>),</span><br><span class="line">       style = el.style;</span><br><span class="line">   <span class="comment">// 使用el和style干点其他什么事...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预解析：var散布的问题"><a href="#预解析：var散布的问题" class="headerlink" title="预解析：var散布的问题"></a>预解析：var散布的问题</h2><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line">myname = <span class="string">&quot;global&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(myname); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">    <span class="keyword">var</span> myname = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    alert(myname); <span class="comment">// &quot;local&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。</p>
<p>上面的代码片段执行的行为可能就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myname = <span class="string">&quot;global&quot;</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> myname; <span class="comment">// 等同于 -&gt; var myname = undefined;</span></span><br><span class="line">   alert(myname); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">   myname = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">   alert(myname); <span class="comment">// &quot;local&quot;&#125;</span></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。</p>
</blockquote>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>在<code>for</code>循环中，你可以循环取得数组或是数组类似对象的值，譬如<code>arguments</code>和<code>HTMLCollection</code>对象。通常的循环形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 次佳的循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myarray.length; i++) &#123;</span><br><span class="line">   <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当<code>myarray</code>不是数组，而是一个<code>HTMLCollection</code>对象的时候。</p>
<p><code>HTMLCollections</code>指的是DOM方法返回的对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByName()</span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName()</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName()</span><br></pre></td></tr></table></figure>
<p>还有其他一些<code>HTMLCollections</code>，这些是在DOM标准之前引进并且现在还在使用的。有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.images: 页面上所有的图片元素</span><br><span class="line"><span class="built_in">document</span>.links : 所有a标签元素</span><br><span class="line"><span class="built_in">document</span>.forms : 所有表单</span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].elements : 页面上第一个表单中的所有域</span><br></pre></td></tr></table></figure>
<p>集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</p>
<p>这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, max = myarray.length; i &lt; max; i++) &#123;</span><br><span class="line">   <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在这个循环过程中，你只检索了一次长度值。</p>
<p>在所有浏览器下，循环获取内容时缓存<code>HTMLCollections</code>的长度是更快的，2倍(Safari3)到190倍(IE7)之间。==//zxx:此数据貌似很老，仅供参考==</p>
<p>注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。</p>
<p>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">        max,</span><br><span class="line">        myarray = [];</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>, max = myarray.length; i &lt; max; i++) &#123;</span><br><span class="line">      <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把<code>i</code>和<code>max</code>引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。</p>
<p>最后一个需要对循环进行调整的是使用下面表达式之一来替换<code>i++</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>JSLint提示您这样做，原因是<code>++</code>和<code>–-</code>促进了“过分棘手(excessive trickiness)”。==//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手==<br>如果你直接无视它，JSLint的<code>plusplus</code>选项会是<code>false</code>（默认是default）。</p>
<p>还有两种变化的形式，其又有了些微改进，因为：</p>
<ul>
<li>少了一个变量(无max)</li>
<li>向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种变化的形式：</span></span><br><span class="line"><span class="keyword">var</span> i, myarray = [];</span><br><span class="line"><span class="keyword">for</span> (i = myarray.length; i–-;) &#123;</span><br><span class="line">   <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第二种使用while循环：</span></span><br><span class="line"><span class="keyword">var</span> myarray = [],</span><br><span class="line">    i = myarray.length;</span><br><span class="line"><span class="keyword">while</span> (i–-) &#123;</span><br><span class="line">   <span class="comment">// 使用myarray[i]做点什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。</p>
<h1 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h1><p><code>for-in</code>循环应该用在非数组对象的遍历上，使用<code>for-in</code>进行循环也被称为“枚举”。</p>
<p>从技术上将，你可以使用<code>for-in</code>循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p>
<p>有个很重要的<code>hasOwnProperty()</code>方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p>
<p>思考下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> man = &#123;</span><br><span class="line">   hands: <span class="number">2</span>,</span><br><span class="line">   legs: <span class="number">2</span>,</span><br><span class="line">   heads: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在代码的某个地方</span></span><br><span class="line"><span class="comment">// 一个方法添加给了所有对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">   <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用<code>hasOwnProperty()</code>方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// for-in 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line">   <span class="keyword">if</span> (man.hasOwnProperty(i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">      <span class="built_in">console</span>.log(i, <span class="string">&quot;:&quot;</span>, man[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 控制台显示结果</span></span><br><span class="line"><span class="comment">hands : 2</span></span><br><span class="line"><span class="comment">legs : 2</span></span><br><span class="line"><span class="comment">heads : 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="comment">// 反面例子:</span></span><br><span class="line"><span class="comment">// for-in loop without checking hasOwnProperty()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i, <span class="string">&quot;:&quot;</span>, man[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制台显示结果</span></span><br><span class="line"><span class="comment">hands : 2</span></span><br><span class="line"><span class="comment">legs : 2</span></span><br><span class="line"><span class="comment">heads : 1</span></span><br><span class="line"><span class="comment">clone: function()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>另外一种使用hasOwnProperty()的形式是取消Object.prototype上的方法。像是：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(man, i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">      <span class="built_in">console</span>.log(i, <span class="string">&quot;:&quot;</span>, man[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> man) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn.call(man, i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">        <span class="built_in">console</span>.log(i, <span class="string">&quot;:&quot;</span>, man[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>严格来说，不使用<code>hasOwnProperty()</code>并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加<code>hasOwnProperty()</code>更加保险些。</p>
</blockquote>
<p>格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 警告： 通不过JSLint检测</span></span><br><span class="line"><span class="keyword">var</span> i, hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> man) <span class="keyword">if</span> (hasOwn.call(man, i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">    <span class="built_in">console</span>.log(i, <span class="string">&quot;:&quot;</span>, man[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="（不）扩展内置原型"><a href="#（不）扩展内置原型" class="headerlink" title="（不）扩展内置原型"></a>（不）扩展内置原型</h1><p>扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。</p>
<p>增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。</p>
<p>另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。</p>
<p>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</p>
<ul>
<li>可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</li>
<li>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。</li>
<li>你清楚地文档记录并和团队交流了变化。</li>
</ul>
<p>如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.protoype.myMethod !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">   <span class="built_in">Object</span>.protoype.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 实现...</span></span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="switch模式"><a href="#switch模式" class="headerlink" title="switch模式"></a>switch模式</h1><p>你可以通过类似下面形式的switch语句增强可读性和健壮性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inspect_me = <span class="number">0</span>,</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (inspect_me) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">   result = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">   result = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   result = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简单的例子中所遵循的风格约定如下：</p>
<ul>
<li>每个case和switch对齐（花括号缩进规则除外）</li>
<li>每个case中代码缩进</li>
<li>每个case以break清除结束</li>
<li>避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。</li>
<li>以default结束switch：确保总有健全的结果，即使无情况匹配。</li>
</ul>
<h1 id="避免隐式类型转换"><a href="#避免隐式类型转换" class="headerlink" title="避免隐式类型转换"></a>避免隐式类型转换</h1><p>JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (zero === <span class="literal">false</span>) &#123;</span><br><span class="line">   <span class="comment">// 不执行，因为zero为0, 而不是false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line"><span class="keyword">if</span> (zero == <span class="literal">false</span>) &#123;</span><br><span class="line">   <span class="comment">// 执行了...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”）</p>
<h1 id="避免eval"><a href="#避免eval" class="headerlink" title="避免eval()"></a>避免eval()</h1><p>如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line"><span class="keyword">var</span> property = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">alert(<span class="built_in">eval</span>(<span class="string">&quot;obj.&quot;</span> + property));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更好的</span></span><br><span class="line"><span class="keyword">var</span> property = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">alert(obj[property]);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。</p>
<p>同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;myFunc()&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;myFunc(1, 2, 3)&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更好的</span></span><br><span class="line"><span class="built_in">setTimeout</span>(myFunc, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。</p>
<p>考虑下面这个例子，这里仅<code>un</code>作为全局变量污染了命名空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> un);    <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> deux); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> trois); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> jsstring = <span class="string">&quot;var un = 1; console.log(un);&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(jsstring); <span class="comment">// logs &quot;1&quot;</span></span><br><span class="line"> </span><br><span class="line">jsstring = <span class="string">&quot;var deux = 2; console.log(deux);&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(jsstring)(); <span class="comment">// logs &quot;2&quot;</span></span><br><span class="line"> </span><br><span class="line">jsstring = <span class="string">&quot;var trois = 3; console.log(trois);&quot;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">eval</span>(jsstring);</span><br><span class="line">&#125;()); <span class="comment">// logs &quot;3&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> un); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> deux); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> trois); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> local = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">eval</span>(<span class="string">&quot;local = 3; console.log(local)&quot;</span>); <span class="comment">// logs &quot;3&quot;</span></span><br><span class="line">   <span class="built_in">console</span>.log(local); <span class="comment">// logs &quot;3&quot;</span></span><br><span class="line">&#125;());</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> local = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">Function</span>(<span class="string">&quot;console.log(typeof local);&quot;</span>)(); <span class="comment">// logs undefined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h1 id="parseInt-下的数值转换"><a href="#parseInt-下的数值转换" class="headerlink" title="parseInt()下的数值转换"></a>parseInt()下的数值转换</h1><p>使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="string">&quot;06&quot;</span>,</span><br><span class="line">    year = <span class="string">&quot;09&quot;</span>;</span><br><span class="line">month = <span class="built_in">parseInt</span>(month, <span class="number">10</span>);</span><br><span class="line">year = <span class="built_in">parseInt</span>(year, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。</p>
<p>替换方法是将字符串转换成数字，包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="string">&quot;08&quot;</span> <span class="comment">// 结果是 8</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;08&quot;</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。</p>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><p>建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。</p>
<p>许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>  代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p>
<p>  一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。</p>
<p>  什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">1</span>,</span><br><span class="line">        d = <span class="number">2</span>,</span><br><span class="line">        inner;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                r: c - d</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                r: c + d</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="花括号"><a href="#花括号" class="headerlink" title="花括号{}"></a>花括号{}</h2><p>花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。</p>
<p>想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的实例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">1</span>)</span><br><span class="line">   alert(i);</span><br></pre></td></tr></table></figure>
<p>但是，如果，后来，主体循环部分又增加了行代码？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的实例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">1</span>)</span><br><span class="line">   alert(i);</span><br><span class="line">   alert(i + <span class="string">&quot; is &quot;</span> + (i % <span class="number">2</span> ? <span class="string">&quot;odd&quot;</span> : <span class="string">&quot;even&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好的实例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">   alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if条件类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 坏</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">   alert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   alert(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   alert(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左花括号的位置"><a href="#左花括号的位置" class="headerlink" title="左花括号的位置"></a>左花括号的位置</h2><p>开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   alert(<span class="string">&quot;It&#x27;s TRUE!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">   alert(<span class="string">&quot;It&#x27;s TRUE!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 警告： 意外的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 下面代码不执行</span></span><br><span class="line">   &#123;</span><br><span class="line">      name : <span class="string">&quot;Batman&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 警告： 意外的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 下面代码不执行</span></span><br><span class="line">   &#123;</span><br><span class="line">      name : <span class="string">&quot;Batman&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，总是使用花括号，并始终把在与之前的语句放在同一行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      name : <span class="string">&quot;Batman&quot;</span></span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。</p>
</blockquote>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p>
<p>适合使用空格的地方包括：</p>
<ul>
<li>for循环分号分开后的的部分：如<code>for (var i = 0; i &lt; 10; i += 1) &#123;...&#125;</code></li>
<li>for循环中初始化的多变量(i和max)：<code>for (var i = 0, max = 10; i &lt; max; i += 1) &#123;...&#125;</code></li>
<li>分隔数组项的逗号的后面：<code>var a = [1, 2, 3];</code></li>
<li>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：<code>var o = &#123;a: 1, b: 2&#125;;</code></li>
<li>限定函数参数：<code>myFunc(a, b, c)</code></li>
<li>函数声明的花括号的前面：<code>function myFunc() &#123;&#125;</code></li>
<li>匿名函数表达式function的后面：<code>var myFunc = function () &#123;&#125;;</code></li>
</ul>
<p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>等前后都需要空格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宽松一致的间距</span></span><br><span class="line"><span class="comment">// 使代码更易读</span></span><br><span class="line"><span class="comment">// 使得更加“透气”</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>,</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &amp;&amp; b &amp;&amp; c) &#123;</span><br><span class="line">    d = a % c;</span><br><span class="line">    a += d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反面例子</span></span><br><span class="line"><span class="comment">// 缺失或间距不一</span></span><br><span class="line"><span class="comment">// 使代码变得疑惑</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>,</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a&amp;&amp;b&amp;&amp;c) &#123;</span><br><span class="line">    d=a % c;</span><br><span class="line">    a+= d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后需要注意的一个空格——花括号间距。最好使用空格：</p>
<ul>
<li>函数、if-else语句、循环、对象字面量的左花括号的前面({)</li>
<li>else或while之间的右花括号(})</li>
</ul>
<p>空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。</p>
<blockquote>
<p>有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</p>
</blockquote>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p>
<p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p>
<h3 id="以大写字母写构造函数"><a href="#以大写字母写构造函数" class="headerlink" title="以大写字母写构造函数"></a>以大写字母写构造函数</h3><p>JavaScript并没有类，但有new调用的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adam = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。</p>
<p>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分隔单词"><a href="#分隔单词" class="headerlink" title="分隔单词"></a>分隔单词</h3><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p>
<p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如<code>MyConstructor()</code>。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是<code>myFunction()</code>, <code>calculateArea()</code>和<code>getFirstName()</code>。</p>
<p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，<code>first_name, favorite_bands,</code> 和 <code>old_company_name</code>，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p>
<p>ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。</p>
<h3 id="其它命名形式"><a href="#其它命名形式" class="headerlink" title="其它命名形式"></a>其它命名形式</h3><p>有时，开发人员使用命名规范来弥补或替代语言特性。</p>
<p>例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 珍贵常数，只可远观</span></span><br><span class="line"><span class="keyword">var</span> PI = <span class="number">3.14</span>,</span><br><span class="line">    MAX_WIDTH = <span class="number">800</span>;</span><br></pre></td></tr></table></figure></p>
<p>还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。</p>
<p>另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._getFirst() + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>._getLast();</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    _getFirst: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _getLast: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在此例中，<code>getName()</code>就表示公共方法，部分稳定的API。而<code>_getFirst()</code>和<code>_getLast()</code>则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。</p>
<p>下面是一些常见的<code>_private</code>规范：</p>
<ul>
<li>使用尾下划线表示私有，如<code>name_</code>和<code>getElements_()</code></li>
<li>使用一个下划线前缀表<code>_protected</code>（保护）属性，两个下划线前缀表示<code>__private</code> （私有）属性</li>
<li>Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：<code>__proto__</code>和<code>__parent__</code>。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p>
<p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p>
<blockquote>
<p>最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。</p>
</blockquote>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客<a href="http://www.zhangxinxu.com/wordpress/2010/10/%e7%bf%bb%e8%af%91-%e9%ab%98%e8%b4%a8%e9%87%8fjavascript%e4%bb%a3%e7%a0%81%e4%b9%a6%e5%86%99%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%82%b9/www.phpied.com">www.phpied.com</a>上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。</p>
<p>本文转自：<a href="http://www.zhangxinxu.com/wordpress/?p=1173">张鑫旭-翻译-高质量JavaScript代码书写基本要点</a></p>
<p>英文原文：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/">http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/</a></p>
<h1 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h1><p>本文转自<a href="http://www.cnblogs.com/TomXu">TOM大叔</a>的<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a></p>
<blockquote>
<p>【深入理解JavaScript系列】文章，包括了原创，翻译，转载，整理等各类型文章，原文是TOM大叔的一个非常不错的专题，现将其重新整理发布。谢谢大叔。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
