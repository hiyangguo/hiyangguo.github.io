<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script><script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;hiyangguo.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><meta name="description" content="背景高阶组件的这种写法的诞生来自于社区的实践，目的是解决一些交叉问题(Cross-Cutting Concerns)。而最早时候 React 官方给出的解决方案是使用 mixin 。而 React 也在官网中写道：  We previously recommended mixins as a way to handle cross-cutting concerns. We’ve since rea"><meta property="og:type" content="article"><meta property="og:title" content="React 高阶组件浅析"><meta property="og:url" content="http://hiyangguo.com/react-hoc-simple-analysis/index.html"><meta property="og:site_name" content="Godfery的博客"><meta property="og:description" content="背景高阶组件的这种写法的诞生来自于社区的实践，目的是解决一些交叉问题(Cross-Cutting Concerns)。而最早时候 React 官方给出的解决方案是使用 mixin 。而 React 也在官网中写道：  We previously recommended mixins as a way to handle cross-cutting concerns. We’ve since rea"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p1.png"><meta property="og:image" content="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p2.png"><meta property="og:image" content="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p3.png"><meta property="og:image" content="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p4.png"><meta property="article:published_time" content="2017-08-24T21:04:26.000Z"><meta property="article:modified_time" content="2022-06-20T13:30:49.363Z"><meta property="article:author" content="Godfery"><meta property="article:tag" content="React"><meta property="article:tag" content="函数式编程"><meta property="article:tag" content="HOC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p1.png"><link rel="canonical" href="http://hiyangguo.com/react-hoc-simple-analysis/"><script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;hiyangguo.com&#x2F;react-hoc-simple-analysis&#x2F;&quot;,&quot;path&quot;:&quot;react-hoc-simple-analysis&#x2F;&quot;,&quot;title&quot;:&quot;React 高阶组件浅析&quot;}</script><script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script><title>React 高阶组件浅析 | Godfery的博客</title><script src="/js/config.js"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Godfery的博客</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fas fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档<span class="badge">22</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签<span class="badge">33</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">高阶函数的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.</span> <span class="nav-text">高阶组件的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">一个简单的高阶组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="nav-number">5.</span> <span class="nav-text">为高阶组件传参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HOC-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">常见的HOC 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86%EF%BC%88Props-Proxy%EF%BC%89%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">基于属性代理（Props Proxy）的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%8D%E5%90%91%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance-Inversion%EF%BC%89%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">基于反向继承（Inheritance Inversion）的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">使用高阶组件遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%A2%E5%A4%B1"><span class="nav-number">7.1.</span> <span class="nav-text">静态方法丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Refs%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.</span> <span class="nav-text">Refs属性不能传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">8.</span> <span class="nav-text">结语</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Godfery" src="/uploads/head.jpg"><p class="site-author-name" itemprop="name">Godfery</p><div class="site-description" itemprop="description">Godfery的博客</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/hiyangguo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hiyangguo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://juejin.im/user/5651d4a860b2ed3620acfaed" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5651d4a860b2ed3620acfaed" rel="noopener" target="_blank"><i class="fas fa-code fa-fw"></i> 掘金</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://wangchujiang.com/FED/" title="https:&#x2F;&#x2F;wangchujiang.com&#x2F;FED&#x2F;" rel="noopener" target="_blank">JSDig</a></li><li class="links-of-blogroll-item"> <a href="https://docschina.org/" title="https:&#x2F;&#x2F;docschina.org&#x2F;" rel="noopener" target="_blank">印记中文</a></li><li class="links-of-blogroll-item"> <a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">腾讯前端导航</a></li><li class="links-of-blogroll-item"> <a href="https://godbasin.github.io/front-end-playground/" title="https:&#x2F;&#x2F;godbasin.github.io&#x2F;front-end-playground&#x2F;" rel="noopener" target="_blank">被删的前端游乐场</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/hiyangguo" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://hiyangguo.com/react-hoc-simple-analysis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/head.jpg"><meta itemprop="name" content="Godfery"><meta itemprop="description" content="Godfery的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Godfery的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> React 高阶组件浅析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-08-24 21:04:26" itemprop="dateCreated datePublished" datetime="2017-08-24T21:04:26+00:00">2017-08-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-06-20 13:30:49" itemprop="dateModified" datetime="2022-06-20T13:30:49+00:00">2022-06-20</time></span><span id="/react-hoc-simple-analysis/" class="post-meta-item leancloud_visitors" data-flag-title="React 高阶组件浅析" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Disqus：</span><a title="disqus" href="/react-hoc-simple-analysis/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="react-hoc-simple-analysis/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>高阶组件的这种写法的诞生来自于社区的实践，目的是解决一些交叉问题(Cross-Cutting Concerns)。而最早时候 <code>React</code> 官方给出的解决方案是使用 <code>mixin</code> 。而 React 也在官网中写道：</p><blockquote><p>We previously recommended mixins as a way to handle cross-cutting concerns. We’ve since realized that mixins create more trouble than they are worth.</p></blockquote><p>官方明显也意识到了使用<code>mixins</code>技术来解决此类问题所带来的困扰远高于其本身的价值。<a target="_blank" rel="noopener" href="https://react.bootcss.com/react/blog/2016/07/13/mixins-considered-harmful.html">更多资料</a>可以查阅官方的说明。</p><h2 id="高阶函数的定义"><a href="#高阶函数的定义" class="headerlink" title="高阶函数的定义"></a>高阶函数的定义</h2><p>说到高阶组件，就不得不先简单的介绍一下高阶函数。下面展示一个最简单的高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x,y,f</span>) =&gt;</span> f(x)+f(y)</span><br></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数 x，y 和f 分别接收 -5，6 和 <code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D;&#x3D;&gt; -5</span><br><span class="line">y &#x3D;&#x3D;&gt; 6</span><br><span class="line">f &#x3D;&#x3D;&gt; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; Math.abs(-5) + Math.abs(6) &#x3D;&#x3D;&gt; 11</span><br></pre></td></tr></table></figure><br>用代码验证一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(-<span class="number">5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs); <span class="comment">//11</span></span><br></pre></td></tr></table></figure><br>高阶在维基百科的定义如下<p></p><blockquote><p>高阶函数是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul></blockquote><h2 id="高阶组件的定义"><a href="#高阶组件的定义" class="headerlink" title="高阶组件的定义"></a>高阶组件的定义</h2><p>那么，什么是高阶组件呢？类比高阶函数的定义，<strong>高阶组件就是接受一个组件作为参数并返回一个新组件的函数</strong>。这里需要注意<strong>高阶组件是一个函数</strong>，并不是组件，这一点一定要注意。<br>同时这里强调一点高阶组件本身并不是 <code>React</code> API。它只是一种模式，这种模式是由 <code>React</code> 自身的组合性质必然产生的。<br>更加通俗的讲，高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。</p><span id="more"></span><h2 id="一个简单的高阶组件"><a href="#一个简单的高阶组件" class="headerlink" title="一个简单的高阶组件"></a>一个简单的高阶组件</h2><p>下面我们来实现一个简单的高阶组件<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;默认标题&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在其他组件中，我们引用这个高阶组件来强化它<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是一个普通组件</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(Demo);</span><br></pre></td></tr></table></figure><p></p><p>下面我们来看一下<code>React DOM Tree</code>，调用了高阶组件之后，发生了什么：<br><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p1.png" alt="图片"></p><p>可以看到，<code>Demo</code> 被 <code>HOC</code> 包裹(wrapped)了之后添加了一个标题默认标题。但是同样会发现，如果调用了多个 <code>HOC</code> 之后，我们会看到很多的<code>HOC</code>，所以应<br>该做一些优化，也就是在高阶组件包裹(wrapped)以后，应该保留原有的名称。</p><p>我们改写一下上述的高阶组件代码，增加一个 <code>getDisplayName</code> 函数，之后为<code>Demo</code> 添加一个静态属性 <code>displayName</code>。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDisplayName = <span class="function"><span class="params">component</span> =&gt;</span> component.displayName || component.name || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;默认标题&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>再次观察<code>React DOM Tree</code></p><p><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p2.png" alt="图片"></p><p>可以看到，该组件原本的名称已经显示在<code>React DOM Tree</code>上了。<br>这个HOC 的功能是为原有的组件添加一个标题，也就是说所有需要添加标题的组件都可以通过调用此 HOC 进行包裹(wrapped) 后实现此功能。</p><h2 id="为高阶组件传参"><a href="#为高阶组件传参" class="headerlink" title="为高阶组件传参"></a>为高阶组件传参</h2><p>现在，我们的 <code>HOC</code> 已经可以为其他任意组件提供标题了，但是我们还希望可以修改标题中的字段。由于我们的高阶组件是一个函数，所以可以为其添加一个参数<code>title</code>。下面我们对<code>HOC</code>进行改写：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (WrappedComponent, title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>之后我们进行调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(Demo,<span class="string">&#x27;高阶组件添加标题&#x27;</span>);</span><br></pre></td></tr></table></figure><br>此时观察<code>React DOM Tree</code>。<p></p><p><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p3.png" alt="图片"></p><p>可以看到，标题已经正确的进行了设置。</p><p>当然我们也可以对其进行柯里化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = withHeader(<span class="string">&#x27;高阶组件添加标题&#x27;</span>)(Demo);</span><br></pre></td></tr></table></figure><h2 id="常见的HOC-实现方式"><a href="#常见的HOC-实现方式" class="headerlink" title="常见的HOC 实现方式"></a>常见的HOC 实现方式</h2><h3 id="基于属性代理（Props-Proxy）的方式"><a href="#基于属性代理（Props-Proxy）的方式" class="headerlink" title="基于属性代理（Props Proxy）的方式"></a>基于属性代理（Props Proxy）的方式</h3><p>属性代理是最常见的高阶组件的使用方式，上面所说的高阶组件就是这种方式。<br>它通过做一些操作，将被包裹组件的<code>props</code>和新生成的<code>props</code>一起传递给此组件，这称之为属性代理。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">GenerateId</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`PropsBorkerHOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        id: <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">2</span>).toUpperCase()</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> createElement(WrappedComponent, &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        ...newProps</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用<code>GenerateId</code>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PropsBorkerDemo = GenerateId(Demo);</span><br></pre></td></tr></table></figure><br>之后我们观察<code>React Dom Tree</code>：<br><img src="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/p4.png" alt="图片"><br>可以看到我们通过 <code>GenerateId</code> 顺利的为 <code>Demo</code> 添加了 <code>id</code>。<p></p><h3 id="基于反向继承（Inheritance-Inversion）的方式"><a href="#基于反向继承（Inheritance-Inversion）的方式" class="headerlink" title="基于反向继承（Inheritance Inversion）的方式"></a>基于反向继承（Inheritance Inversion）的方式</h3><p>首先来看一个简单的反向继承的例子：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`InheritanceHOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以方便地得到state，做一些更深入的修改。</span></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        innerText: <span class="string">&#x27;我被Inheritance修改了值&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如你所见返回的高阶组件类（<code>Enhancer</code>）继承了 <code>WrappedComponent</code>。而之所以被称为反向继承是因为 <code>WrappedComponent</code> 被动地被 <code>Enhancer</code><br>继承，而不是 <code>WrappedComponent</code> 去继承 <code>Enhancer</code>。通过这种方式他们之间的关系倒转了。<p></p><p>反向继承允许高阶组件通过 <code>this</code> 关键词获取 <code>WrappedComponent</code>，意味着它可以获取到 <code>state</code>，<code>props</code>，组件生命周期（Component Lifecycle）钩子，以及渲染方法（render）。<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/0aae7d4d9bc1">深入了解</a>可以阅读<strong>@Wenliang</strong>文章中<code>Inheritance Inversion（II）</code>这一节的内容。</p><h2 id="使用高阶组件遇到的问题"><a href="#使用高阶组件遇到的问题" class="headerlink" title="使用高阶组件遇到的问题"></a>使用高阶组件遇到的问题</h2><h3 id="静态方法丢失"><a href="#静态方法丢失" class="headerlink" title="静态方法丢失"></a>静态方法丢失</h3><p>当使用高阶组件包装组件，原始组件被容器组件包裹，也就意味着新组件会丢失原始组件的所有静态方法。<br>下面为 Demo 添加一个静态方法：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo.getDisplayName = <span class="function">() =&gt;</span> <span class="string">&#x27;Demo&#x27;</span>;</span><br></pre></td></tr></table></figure><br>之后调用 <code>HOC</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> WithHeaderDemo = HOC(Demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用后的组件是没有 `getDisplayName` 方法的</span></span><br><span class="line"><span class="keyword">typeof</span> WithHeaderDemo.getDisplayName === <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>解决这个问题最简单(Yǘ Chǚn)的方法就是，将原始组件的所有静态方法全部拷贝给新组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;fieldset&gt;</span><br><span class="line">          &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;/fieldset&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> HOC.getDisplayName = WrappedComponent.getDisplayName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HOC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样做，就需要你清楚的知道都有哪些静态方法需要拷贝的。或者你也可是使用<a target="_blank" rel="noopener" href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来帮你自动处理，它会自动拷贝所有非React的静态方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (title = <span class="string">&#x27;默认标题&#x27;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;fieldset&gt;</span><br><span class="line">          &lt;legend&gt;&#123;title&#125;&lt;/legend&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;/fieldset&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝静态方法</span></span><br><span class="line">  hoistNonReactStatic(HOC, WrappedComponent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HOC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="Refs属性不能传递"><a href="#Refs属性不能传递" class="headerlink" title="Refs属性不能传递"></a>Refs属性不能传递</h3><p>一般来说，高阶组件可以传递所有的props属性给包裹的组件，但是不能传递 <code>refs</code> 引用。因为并不是像 <code>key</code> 一样，<code>refs</code> 是一个伪属性，<code>React</code> 对它进行了特殊处理。<br>如果你向一个由高级组件创建的组件的元素添加 <code>ref</code> 应用，那么 <code>ref</code> 指向的是最外层容器组件实例的，而不是包裹组件。<br>但有的时候，我们不可避免要使用 <code>refs</code>，官方给出的解决方案是：</p><blockquote><p>传递一个ref回调函数属性，也就是给ref应用一个不同的名字</p></blockquote><p>同时还强调道：<strong>React在任何时候都不建议使用 ref应用</strong><br>改写 <code>Demo</code><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    getRef: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDisplayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Demo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      innerText: <span class="string">&#x27;我是一个普通组件&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getRef, ...props &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;getRef&#125; &#123;...props&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.innerText&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后我们进行调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;WithHeaderDemo</span><br><span class="line">  getRef=&#123;<span class="function">(<span class="params">ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 该回调函数被作为常规的props属性传递</span></span><br><span class="line">    <span class="built_in">this</span>.headerDemo = ref;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><br>虽然这并不是最完美的解决方案，但是<code>React</code>官方说他们正在探索解决这个问题的方法，能够让我们安心的使用高阶组件而不必关注这个问题。<p></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章只是简单的介绍了高阶组件的两种最常见的使用方式：<code>属性代理</code>和<code>反向继承</code>。以及高阶组件的常见问题。希望通过本文的阅读使你对高阶组件有一个基本的认识。<br>写本文所产生的代码在<a target="_blank" rel="noopener" href="https://github.com/hiyangguo/study-hoc">study-hoc</a>中。</p><blockquote><p>本文作者：<a target="_blank" rel="noopener" href="https://github.com/hiyangguo">杨过</a><br>本文同步发表于：<a target="_blank" rel="noopener" href="http://blog.hypers.io/2017/08/24/react-hoc-simple-analysis/">HYPERS 前端博客</a></p></blockquote><p>参考文章:</p><blockquote><p><a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/higher-order-components.html">Higher-Order Components</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AdP-3oA9ofv9hQfDc2r7KA">深入浅出React高阶组件</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59818a485188255694568ff2">带着三个问题一起深入浅出React高阶组件</a><br><a target="_blank" rel="noopener" href="http://t.cn/RKWUqko">阮一峰 - 高阶函数</a><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/0aae7d4d9bc1">深入理解高阶组件</a></p></blockquote></div><footer class="post-footer"><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button onclick='document.querySelector(".post-reward").classList.toggle("active")'> 赞赏</button><div class="post-reward"><div> <img src="/path/to/wechat-reward-image.png" alt="Godfery 微信"> <span>微信</span></div><div> <img src="/path/to/alipay-reward-image.png" alt="Godfery 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Godfery</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://hiyangguo.com/react-hoc-simple-analysis/" title="React 高阶组件浅析">http://hiyangguo.com/react-hoc-simple-analysis/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.zh-Hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"> <a href="/tags/React/" rel="tag"># React</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"># 函数式编程</a> <a href="/tags/HOC/" rel="tag"># HOC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/git-tutorials/" rel="prev" title="Git使用入门教程"><i class="fa fa-chevron-left"></i> Git使用入门教程</a></div><div class="post-nav-item"> <a href="/build-a-app-width-electron-and-react/" rel="next" title="如何使用 Electron 和 React 构建一个 APP">如何使用 Electron 和 React 构建一个 APP<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 – <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Godfery</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script><script src="/js/third-party/nprogress.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{&quot;enable&quot;:true,&quot;app_id&quot;:&quot;2jwVI58glS0nRFUd0v7YwmSE-gzGzoHsz&quot;,&quot;app_key&quot;:&quot;BrxDua0t4Dci3dlvkby5JuJo&quot;,&quot;server_url&quot;:&quot;https:&#x2F;&#x2F;2jwvi58g.lc-cn-n1-shared.com&quot;,&quot;security&quot;:false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script><script class="next-config" data-name="quicklink" type="application/json">{&quot;enable&quot;:true,&quot;home&quot;:false,&quot;archive&quot;:false,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;hiyangguo.com&#x2F;react-hoc-simple-analysis&#x2F;&quot;}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;godeferyde-bo-ke&quot;,&quot;count&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script><script src="/js/third-party/comments/disqus.js"></script></body></html>